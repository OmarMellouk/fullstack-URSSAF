import { CommunicationSPAServiceFactory } from '@acoss/communication-spa-core/dist/main/CommunicationSPAService';
import * as i0 from '@angular/core';
import { InjectionToken, NgModule, Inject, Optional, SkipSelf } from '@angular/core';

const APP_NAME_VALUE_HOLDER = new InjectionToken('AppNameHolder');
class CommunicationSPAModule {
    // Constructeur qui permet d'initier l'implémentation TS avec le Title de la WebApp Angular
    constructor(appName, parentModule) {
        if (parentModule) {
            throw new Error('CommunicationSPAModule is already loaded. Import it in the AppModule only');
        }
        this.myService = CommunicationSPAServiceFactory.getCommunicationSPAService(appName);
    }
    static forRoot(appName) {
        return {
            ngModule: CommunicationSPAModule,
            providers: [
                { provide: APP_NAME_VALUE_HOLDER, useValue: appName }
            ]
        };
    }
    /**
     * Méthode à appeler une fois les handlers enregistrés afin d'activer la communication
     * La méthode aura pour effet de débloquer l'envoi des messages d'init par le parent
     */
    applicationReadyActivateCommunication() {
        this.myService.applicationReadyActivateCommunication();
    }
    /**
     * Retourne l'identifiant unique du service de messagerie (= identifiant émetteur)
     * @returns UUID du compposant de messagerie
     */
    getUUID() {
        return this.myService.getUUID();
    }
    /**
     * Ajout d'un composant enfant de communication inter IHM
     * Permet d'ouvrir le canal de communication via le Handshake
     * @param componentWindow Composant HTML qui sera utilisé pour réaliser la communication
     * @param handshakeTimeoutMS Délai d'attente de résolution du handshake avant levée d'une erreur
     * @param timeoutCallback Fonction callback appelé en cas de levée du timeout
     * @returns UUID du composant enfant (vision parent != uuid vision enfant)
     */
    addChildComponent(componentWindow, handshakeTimeoutMS, timeoutCallback) {
        return this.myService.addChildComponent(componentWindow, handshakeTimeoutMS, timeoutCallback);
    }
    /**
     * Recherche de l'UUID réel (!vision parent) ayant l'UUID enfant fourni (vision parent)
     *
     * @param componentUUID UUID local du composant
     * @returns UUID réel du composant s'il est connu (= handshake realisé et enfant de niveau 1)
     */
    getChildToRealUUID(componentUUID) {
        return this.myService.getChildToRealUUID(componentUUID);
    }
    /**
     * Recherche de l'UUID enfant (vision parent) ayant l'UUID réel (!vision parent) fourni
     *
     * @param realUUID UUID réel du composant dont on souhaite rechercher l'UUID enfant (du composant local)
     * @returns UUID enfant du composant s'il est connu (= handshake realisé et enfant de niveau 1)
     */
    getRealToChildUUID(realUUID) {
        return this.myService.getRealToChildUUID(realUUID);
    }
    /**
     * Suppression d'un composant enfant
     * @param componentUUID UUID du composant enfant à supprimer
     */
    removeChildComponent(componentUUID) {
        this.myService.removeChildComponent(componentUUID);
    }
    /**
     * Suppression de tous les composants et souscriptions enregistrées
     */
    destroy() {
        return this.myService.destroy();
    }
    /**
     * Souscription à un type de message
     *
     * La fonction est activiée à reception d'un message si le namespace ET le topic matchent
     *
     * @param namespaceRegEx RegEx de match sur le namespace
     * @param topicRegEx RegEx de match sur le topic
     * @param handlerFunction Fonction qui sera déclanchée sur match namespaceRegEx ET topicRegEx
     * @returns UUID de la souscription
     */
    subscribe(namespaceRegEx, topicRegEx, handlerFunction) {
        return this.myService.subscribe(namespaceRegEx, topicRegEx, handlerFunction);
    }
    /**
     * Suppression d'une souscription
     * @param observerUUID UUID de la souscription à supprimer
     */
    unsubscribe(observerUUID) {
        return this.myService.unsubscribe(observerUUID);
    }
    /**
     * Suppression de toutes les souscriptions
     */
    unsubscribeAll() {
        return this.myService.unsubscribeAll();
    }
    /**
     * Envoi d'un message de type INIT, il est garanti que ces messages ne seront tranmis qu'une fois le
     * handshake finalisé avec le composant IHM enfant
     *
     * (Seul les messages init ont cette particularité, l'ensemble des autres messages sont transmis directement et ne seront pas
     * reçus sur le composant n'a pas finalisé son chargement et mis en place les handlers d'évènements)
     *
     * @param namespace namespace du message
     * @param topic topic du message
     * @param payload objet fonctionnel/métier qui sera transmis
     * @param componentUUID UUID du composant IHM à qui envoyer le message
     */
    sendChildInitMessage(namespace, topic, payload, componentUUID) {
        return this.myService.sendChildInitMessage(namespace, topic, payload, componentUUID);
    }
    /**
     * Envoi d'un message de réponse à un message émis.
     * La méthode nécessite de connaitre le MessageDTO et sera donc uniquement appelable via un handler de communication Applicatif
     * @param namespace namespace du message
     * @param topic topic du message
     * @param payload objet fonctionnel/métier qui sera transmis
     * @param originMessageObject Message d'origine entrainant la réponse
     */
    sendReplyMessage(namespace, topic, payload, originMessageObject) {
        return this.myService.sendReplyMessage(namespace, topic, payload, originMessageObject);
    }
    /**
     * Envoi d'un message BROADCAST, qui sera transmis à tous les composants IHM enregistrés
     * (tous les parents et tous les enfants...)
     * Les messages seront traités sous forme de message CHILDS
     *
     * @param namespace namespace du message
     * @param topic topic du message
     * @param payload objet fonctionnel/métier qui sera transmis
     */
    sendBroadcastMessage(namespace, topic, payload) {
        return this.myService.sendBroadcastMessage(namespace, topic, payload);
    }
    /**
     * Envoi d'un message CHILDS, qui sera transmis à tous les composants enfant IHM enregistrés
     * @param namespace namespace du message
     * @param topic topic du message
     * @param payload objet fonctionnel/métier qui sera transmis
     */
    sendChildrenMessage(namespace, topic, payload) {
        return this.myService.sendChildrenMessage(namespace, topic, payload);
    }
    /**
     * Envoi d'un message DIRECT à un enfant spécifique
     * @param namespace namespace du message
     * @param topic topic du message
     * @param payload objet fonctionnel/métier qui sera transmis
     * @param componentUUID UUID du composant enfant auquel on souhaite envoyer le message
     */
    sendChildMessage(namespace, topic, payload, componentUUID) {
        return this.myService.sendChildMessage(namespace, topic, payload, componentUUID);
    }
    /**
     * Envoi d'un message DIRECT au composant parent (s'il existe)
     * @param namespace namespace du message
     * @param topic topic du message
     * @param payload objet fonctionnel/métier qui sera transmis
     * @returns true si le message a été émis, false s'il n'y a pas d'application parent à qui envoyer un message
     */
    sendParentMessage(namespace, topic, payload) {
        return this.myService.sendParentMessage(namespace, topic, payload);
    }
}
/** @nocollapse */ CommunicationSPAModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: CommunicationSPAModule, deps: [{ token: APP_NAME_VALUE_HOLDER }, { token: CommunicationSPAModule, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ CommunicationSPAModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.1.0", ngImport: i0, type: CommunicationSPAModule });
/** @nocollapse */ CommunicationSPAModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: CommunicationSPAModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: CommunicationSPAModule, decorators: [{
            type: NgModule,
            args: [{}]
        }], ctorParameters: function () {
        return [{ type: undefined, decorators: [{
                        type: Inject,
                        args: [APP_NAME_VALUE_HOLDER]
                    }] }, { type: CommunicationSPAModule, decorators: [{
                        type: Optional
                    }, {
                        type: SkipSelf
                    }] }];
    } });

/*
 * Public API Surface of communication-spa-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { APP_NAME_VALUE_HOLDER, CommunicationSPAModule };
//# sourceMappingURL=acoss-communication-spa-angular.mjs.map
