import { ICommunicationSPAService, MessageDTO, MessageHandler } from '@acoss/communication-spa-core';
import { InjectionToken, ModuleWithProviders } from '@angular/core';
import * as i0 from "@angular/core";
export declare const APP_NAME_VALUE_HOLDER: InjectionToken<string>;
export declare class CommunicationSPAModule implements ICommunicationSPAService {
    private myService;
    static forRoot(appName: string): ModuleWithProviders<CommunicationSPAModule>;
    constructor(appName: string, parentModule: CommunicationSPAModule);
    /**
     * Méthode à appeler une fois les handlers enregistrés afin d'activer la communication
     * La méthode aura pour effet de débloquer l'envoi des messages d'init par le parent
     */
    applicationReadyActivateCommunication(): void;
    /**
     * Retourne l'identifiant unique du service de messagerie (= identifiant émetteur)
     * @returns UUID du compposant de messagerie
     */
    getUUID(): string;
    /**
     * Ajout d'un composant enfant de communication inter IHM
     * Permet d'ouvrir le canal de communication via le Handshake
     * @param componentWindow Composant HTML qui sera utilisé pour réaliser la communication
     * @param handshakeTimeoutMS Délai d'attente de résolution du handshake avant levée d'une erreur
     * @param timeoutCallback Fonction callback appelé en cas de levée du timeout
     * @returns UUID du composant enfant (vision parent != uuid vision enfant)
     */
    addChildComponent(componentWindow: Window, handshakeTimeoutMS: number, timeoutCallback: any): string;
    /**
     * Recherche de l'UUID réel (!vision parent) ayant l'UUID enfant fourni (vision parent)
     *
     * @param componentUUID UUID local du composant
     * @returns UUID réel du composant s'il est connu (= handshake realisé et enfant de niveau 1)
     */
    getChildToRealUUID(componentUUID: string): string | undefined;
    /**
     * Recherche de l'UUID enfant (vision parent) ayant l'UUID réel (!vision parent) fourni
     *
     * @param realUUID UUID réel du composant dont on souhaite rechercher l'UUID enfant (du composant local)
     * @returns UUID enfant du composant s'il est connu (= handshake realisé et enfant de niveau 1)
     */
    getRealToChildUUID(realUUID: string): string | undefined;
    /**
     * Suppression d'un composant enfant
     * @param componentUUID UUID du composant enfant à supprimer
     */
    removeChildComponent(componentUUID: string): void;
    /**
     * Suppression de tous les composants et souscriptions enregistrées
     */
    destroy(): void;
    /**
     * Souscription à un type de message
     *
     * La fonction est activiée à reception d'un message si le namespace ET le topic matchent
     *
     * @param namespaceRegEx RegEx de match sur le namespace
     * @param topicRegEx RegEx de match sur le topic
     * @param handlerFunction Fonction qui sera déclanchée sur match namespaceRegEx ET topicRegEx
     * @returns UUID de la souscription
     */
    subscribe(namespaceRegEx: string, topicRegEx: string, handlerFunction: MessageHandler): string;
    /**
     * Suppression d'une souscription
     * @param observerUUID UUID de la souscription à supprimer
     */
    unsubscribe(observerUUID: string): void;
    /**
     * Suppression de toutes les souscriptions
     */
    unsubscribeAll(): void;
    /**
     * Envoi d'un message de type INIT, il est garanti que ces messages ne seront tranmis qu'une fois le
     * handshake finalisé avec le composant IHM enfant
     *
     * (Seul les messages init ont cette particularité, l'ensemble des autres messages sont transmis directement et ne seront pas
     * reçus sur le composant n'a pas finalisé son chargement et mis en place les handlers d'évènements)
     *
     * @param namespace namespace du message
     * @param topic topic du message
     * @param payload objet fonctionnel/métier qui sera transmis
     * @param componentUUID UUID du composant IHM à qui envoyer le message
     */
    sendChildInitMessage(namespace: string, topic: string, payload: any | undefined, componentUUID: string): void;
    /**
     * Envoi d'un message de réponse à un message émis.
     * La méthode nécessite de connaitre le MessageDTO et sera donc uniquement appelable via un handler de communication Applicatif
     * @param namespace namespace du message
     * @param topic topic du message
     * @param payload objet fonctionnel/métier qui sera transmis
     * @param originMessageObject Message d'origine entrainant la réponse
     */
    sendReplyMessage(namespace: string, topic: string, payload: any | undefined, originMessageObject: MessageDTO): void;
    /**
     * Envoi d'un message BROADCAST, qui sera transmis à tous les composants IHM enregistrés
     * (tous les parents et tous les enfants...)
     * Les messages seront traités sous forme de message CHILDS
     *
     * @param namespace namespace du message
     * @param topic topic du message
     * @param payload objet fonctionnel/métier qui sera transmis
     */
    sendBroadcastMessage(namespace: string, topic: string, payload: any | undefined): void;
    /**
     * Envoi d'un message CHILDS, qui sera transmis à tous les composants enfant IHM enregistrés
     * @param namespace namespace du message
     * @param topic topic du message
     * @param payload objet fonctionnel/métier qui sera transmis
     */
    sendChildrenMessage(namespace: string, topic: string, payload: any | undefined): void;
    /**
     * Envoi d'un message DIRECT à un enfant spécifique
     * @param namespace namespace du message
     * @param topic topic du message
     * @param payload objet fonctionnel/métier qui sera transmis
     * @param componentUUID UUID du composant enfant auquel on souhaite envoyer le message
     */
    sendChildMessage(namespace: string, topic: string, payload: any | undefined, componentUUID: string): void;
    /**
     * Envoi d'un message DIRECT au composant parent (s'il existe)
     * @param namespace namespace du message
     * @param topic topic du message
     * @param payload objet fonctionnel/métier qui sera transmis
     * @returns true si le message a été émis, false s'il n'y a pas d'application parent à qui envoyer un message
     */
    sendParentMessage(namespace: string, topic: string, payload: any | undefined): boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<CommunicationSPAModule, [null, { optional: true; skipSelf: true; }]>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<CommunicationSPAModule, never, never, never>;
    static ɵinj: i0.ɵɵInjectorDeclaration<CommunicationSPAModule>;
}
