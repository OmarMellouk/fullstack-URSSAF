{"version":3,"file":"acoss-communication-spa-angular.mjs","sources":["../../../../projects/acoss/communication-spa-angular/src/lib/communication-spa.module.ts","../../../../projects/acoss/communication-spa-angular/src/public-api.ts","../../../../projects/acoss/communication-spa-angular/src/acoss-communication-spa-angular.ts"],"sourcesContent":["import { ICommunicationSPAService, MessageDTO, MessageHandler} from '@acoss/communication-spa-core';\nimport { CommunicationSPAServiceFactory } from '@acoss/communication-spa-core/dist/main/CommunicationSPAService';\nimport { Inject, InjectionToken, ModuleWithProviders, NgModule, Optional, SkipSelf } from '@angular/core';\n\n\n\nexport const APP_NAME_VALUE_HOLDER = new InjectionToken<string>('AppNameHolder');\n\n@NgModule({\n})\nexport class CommunicationSPAModule implements ICommunicationSPAService {\n\n  // Lien vers l'implémentation TS\n  private myService!: ICommunicationSPAService;\n\n  public static forRoot(appName: string): ModuleWithProviders<CommunicationSPAModule> {\n    return {\n      ngModule: CommunicationSPAModule,\n      providers: [\n        {provide: APP_NAME_VALUE_HOLDER, useValue: appName}\n      ]\n    };\n  }\n\n  // Constructeur qui permet d'initier l'implémentation TS avec le Title de la WebApp Angular\n  public constructor(@Inject(APP_NAME_VALUE_HOLDER) appName: string, @Optional() @SkipSelf() parentModule: CommunicationSPAModule) {\n    if (parentModule) {\n      throw new Error(\n        'CommunicationSPAModule is already loaded. Import it in the AppModule only');\n    }\n\n    this.myService = CommunicationSPAServiceFactory.getCommunicationSPAService(appName);\n  }\n\n  /**\n   * Méthode à appeler une fois les handlers enregistrés afin d'activer la communication\n   * La méthode aura pour effet de débloquer l'envoi des messages d'init par le parent\n   */\n  public applicationReadyActivateCommunication(): void {\n    this.myService.applicationReadyActivateCommunication();\n  }\n\n  /**\n   * Retourne l'identifiant unique du service de messagerie (= identifiant émetteur)\n   * @returns UUID du compposant de messagerie\n   */\n  public getUUID(): string {\n    return this.myService.getUUID();\n  }\n\n  /**\n   * Ajout d'un composant enfant de communication inter IHM\n   * Permet d'ouvrir le canal de communication via le Handshake\n   * @param componentWindow Composant HTML qui sera utilisé pour réaliser la communication\n   * @param handshakeTimeoutMS Délai d'attente de résolution du handshake avant levée d'une erreur\n   * @param timeoutCallback Fonction callback appelé en cas de levée du timeout\n   * @returns UUID du composant enfant (vision parent != uuid vision enfant)\n   */\n  public addChildComponent(componentWindow: Window, handshakeTimeoutMS: number, timeoutCallback: any): string {\n    return this.myService.addChildComponent(componentWindow, handshakeTimeoutMS, timeoutCallback);\n  }\n\n  /**\n   * Recherche de l'UUID réel (!vision parent) ayant l'UUID enfant fourni (vision parent)\n   *\n   * @param componentUUID UUID local du composant\n   * @returns UUID réel du composant s'il est connu (= handshake realisé et enfant de niveau 1)\n   */\n  public getChildToRealUUID(componentUUID: string): string|undefined {\n    return this.myService.getChildToRealUUID(componentUUID);\n  }\n\n  /**\n   * Recherche de l'UUID enfant (vision parent) ayant l'UUID réel (!vision parent) fourni\n   *\n   * @param realUUID UUID réel du composant dont on souhaite rechercher l'UUID enfant (du composant local)\n   * @returns UUID enfant du composant s'il est connu (= handshake realisé et enfant de niveau 1)\n   */\n  public getRealToChildUUID(realUUID: string): string|undefined {\n    return this.myService.getRealToChildUUID(realUUID);\n  }\n\n  /**\n   * Suppression d'un composant enfant\n   * @param componentUUID UUID du composant enfant à supprimer\n   */\n  public removeChildComponent(componentUUID: string): void {\n    this.myService.removeChildComponent(componentUUID);\n  }\n\n  /**\n   * Suppression de tous les composants et souscriptions enregistrées\n   */\n  public destroy(): void {\n    return this.myService.destroy();\n  }\n\n  /**\n   * Souscription à un type de message\n   *\n   * La fonction est activiée à reception d'un message si le namespace ET le topic matchent\n   *\n   * @param namespaceRegEx RegEx de match sur le namespace\n   * @param topicRegEx RegEx de match sur le topic\n   * @param handlerFunction Fonction qui sera déclanchée sur match namespaceRegEx ET topicRegEx\n   * @returns UUID de la souscription\n   */\n  public subscribe(namespaceRegEx: string, topicRegEx: string, handlerFunction: MessageHandler): string {\n    return this.myService.subscribe(namespaceRegEx, topicRegEx, handlerFunction);\n  }\n  /**\n   * Suppression d'une souscription\n   * @param observerUUID UUID de la souscription à supprimer\n   */\n  public unsubscribe(observerUUID: string): void {\n    return this.myService.unsubscribe(observerUUID);\n  }\n  /**\n   * Suppression de toutes les souscriptions\n   */\n  public unsubscribeAll(): void {\n    return this.myService.unsubscribeAll();\n  }\n\n  /**\n   * Envoi d'un message de type INIT, il est garanti que ces messages ne seront tranmis qu'une fois le\n   * handshake finalisé avec le composant IHM enfant\n   *\n   * (Seul les messages init ont cette particularité, l'ensemble des autres messages sont transmis directement et ne seront pas\n   * reçus sur le composant n'a pas finalisé son chargement et mis en place les handlers d'évènements)\n   *\n   * @param namespace namespace du message\n   * @param topic topic du message\n   * @param payload objet fonctionnel/métier qui sera transmis\n   * @param componentUUID UUID du composant IHM à qui envoyer le message\n   */\n  public sendChildInitMessage(namespace: string, topic: string, payload: any | undefined, componentUUID: string): void {\n    return this.myService.sendChildInitMessage(namespace, topic, payload, componentUUID);\n  }\n  /**\n   * Envoi d'un message de réponse à un message émis.\n   * La méthode nécessite de connaitre le MessageDTO et sera donc uniquement appelable via un handler de communication Applicatif\n   * @param namespace namespace du message\n   * @param topic topic du message\n   * @param payload objet fonctionnel/métier qui sera transmis\n   * @param originMessageObject Message d'origine entrainant la réponse\n   */\n  public sendReplyMessage(namespace: string, topic: string, payload: any | undefined, originMessageObject: MessageDTO): void {\n    return this.myService.sendReplyMessage(namespace, topic, payload, originMessageObject);\n  }\n  /**\n   * Envoi d'un message BROADCAST, qui sera transmis à tous les composants IHM enregistrés\n   * (tous les parents et tous les enfants...)\n   * Les messages seront traités sous forme de message CHILDS\n   *\n   * @param namespace namespace du message\n   * @param topic topic du message\n   * @param payload objet fonctionnel/métier qui sera transmis\n   */\n  public sendBroadcastMessage(namespace: string, topic: string, payload: any | undefined): void {\n    return this.myService.sendBroadcastMessage(namespace, topic, payload);\n  }\n  /**\n   * Envoi d'un message CHILDS, qui sera transmis à tous les composants enfant IHM enregistrés\n   * @param namespace namespace du message\n   * @param topic topic du message\n   * @param payload objet fonctionnel/métier qui sera transmis\n   */\n  public sendChildrenMessage(namespace: string, topic: string, payload: any | undefined): void {\n    return this.myService.sendChildrenMessage(namespace, topic, payload);\n  }\n  /**\n   * Envoi d'un message DIRECT à un enfant spécifique\n   * @param namespace namespace du message\n   * @param topic topic du message\n   * @param payload objet fonctionnel/métier qui sera transmis\n   * @param componentUUID UUID du composant enfant auquel on souhaite envoyer le message\n   */\n  public sendChildMessage(namespace: string, topic: string, payload: any | undefined, componentUUID: string): void {\n    return this.myService.sendChildMessage(namespace, topic, payload, componentUUID);\n  }\n  /**\n   * Envoi d'un message DIRECT au composant parent (s'il existe)\n   * @param namespace namespace du message\n   * @param topic topic du message\n   * @param payload objet fonctionnel/métier qui sera transmis\n   * @returns true si le message a été émis, false s'il n'y a pas d'application parent à qui envoyer un message\n   */\n  public sendParentMessage(namespace: string, topic: string, payload: any | undefined): boolean {\n    return this.myService.sendParentMessage(namespace, topic, payload);\n  }\n}\n","/*\n * Public API Surface of communication-spa-angular\n */\n\nexport * from './lib/communication-spa.module';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}