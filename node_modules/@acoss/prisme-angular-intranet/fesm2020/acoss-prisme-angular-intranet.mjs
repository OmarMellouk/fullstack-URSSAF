import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Inject, Component, NgModule } from '@angular/core';
import * as i3 from '@angular/router';
import { RouterModule } from '@angular/router';
import * as pako from 'pako';
import { JwtHelperService } from '@auth0/angular-jwt';
import * as i4 from '@angular/common/http';
import { HttpHeaders, HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import * as jsrsasign from 'jsrsasign';
import { Subject, timer, throwError } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { StorageServiceModule } from 'ngx-webstorage-service';

class AbstractSuccessLoginHandler {
    successLogin() {
        this.postSuccessLogin();
    }
}

class AbstractFailureLoginHandler {
    failureLogin(loginService) {
        // On Force la déconnection si l'utilisateur ne s'est pas authentifié correctement
        loginService.deconnecter();
        console.log('Dans AbstractFailureLoginHandler');
        this.postFailureLogin();
    }
}

// Token permettant d'injecter le success_handler
const PRISME_SUCCESS_LOGIN_HANDLER = new InjectionToken('PRISME_SUCCESS_LOGIN_HANDLER');
// Token permettant d'injecter le success_handler
const PRISME_FAILURE_LOGIN_HANDLER = new InjectionToken('PRISME_FAILURE_LOGIN_HANDLER');
// Classe permettant de travailler sur les paramètres fournie par l'application afin d'ajouter du comportement
// Cette classe est la configuration "interne" de la librairie prisme
// A la constrcution on copie l'ensemble des paramètres écrits dans la configuration de l'application appelante dans cette classe
// @Injectable({
//   providedIn: 'root'
// })
class PrismeAngularConfiguration {
    constructor(appconf) {
        this.appconf = appconf;
        // Si appConf n'est pas null, alors on contruit la configuration a partir de appConf
        // Sinon, la classe appelante doit fournir les informations "une à une"
        if (appconf) {
            // Vérification des urls des Enpoints et affectation des endpoints à partir de prismeUrlBaseEndpoints (si )
            this.setPrismeEndpoints(appconf);
            this.prismeIss = this.appconf.prismeIss;
            this.prismeScopeBack = this.appconf.prismeScopeBack;
            this.prismeClientSecret = this.appconf.prismeClientSecret;
            this.prismeClientId = this.appconf.prismeClientId;
            this.prismeCodeApp = this.appconf.prismeCodeApp;
            this.prismeScopeFront = this.appconf.prismeScopeFront;
            this.applicationUri = this.addHttpIsNecessary(this.appconf.applicationUri);
            this.prismeRefreshTokensInterval = this.appconf.prismeRefreshTokensInterval;
            this.iFrameRenouvellement = this.appconf.iFrameRenouvellement;
            this.pageApresConnexion = this.appconf.pageApresConnexion;
            this.chargerUserInfosBack = this.appconf.chargerUserInfosBack;
            this.chargerUserInfosFront = this.appconf.chargerUserInfosFront;
            this.jetonReadyTopic = this.appconf.jetonReadyTopic;
            this.jetonMessageTopic = this.appconf.jetonMessageTopic;
            this.waitWebMessageURLFragment = this.appconf.waitWebMessageURLFragment;
        }
    }
    replaceIfNull(parameterToTest, replaceBy) {
        if (parameterToTest == null) {
            return replaceBy;
        }
        else {
            return parameterToTest;
        }
    }
    addHttpIsNecessary(parameterToTest) {
        if (parameterToTest.startsWith('http')) {
            return parameterToTest;
        }
        else {
            return 'http://' + parameterToTest;
        }
    }
    /**
     * Affecte les endPoints à partir de prismeUrlBaseEndpoint
     * Vérifie si les valeurs sont bien affectées
     * @param length Longueur
     */
    setPrismeEndpoints(conf) {
        if (conf.prismeUrlBaseEndpoint != null) {
            this.prismeUrlBaseEndpoint = conf.prismeUrlBaseEndpoint;
            // On enleve le / a la fin si il est présent
            if (this.prismeUrlBaseEndpoint.endsWith('/')) {
                this.prismeUrlBaseEndpoint = this.prismeUrlBaseEndpoint.slice(0, this.prismeUrlBaseEndpoint.length - 1);
            }
            this.prismeAuthzEndpoint = this.replaceIfNull(conf.prismeAuthzEndpoint, this.prismeUrlBaseEndpoint + '/security/v1/pss/authz');
            this.prismeTokenEndpoint = this.replaceIfNull(conf.prismeTokenEndpoint, this.prismeUrlBaseEndpoint + '/security/v1/pss/token');
            this.prismeKeysEndpoint = this.replaceIfNull(conf.prismeKeysEndpoint, this.prismeUrlBaseEndpoint + '/security/v1/pss/jwks/public');
            this.prismeUserEndpoint = this.replaceIfNull(conf.prismeUserEndpoint, this.prismeUrlBaseEndpoint + '/security/v1/pss/user-info');
        }
        else {
            this.prismeAuthzEndpoint = conf.prismeAuthzEndpoint;
            this.prismeTokenEndpoint = conf.prismeTokenEndpoint;
            this.prismeKeysEndpoint = conf.prismeKeysEndpoint;
            this.prismeUserEndpoint = conf.prismeUserEndpoint;
        }
        // On remplace les // par des / car pose problème
        this.prismeAuthzEndpoint = this.prismeAuthzEndpoint.replace(/([^:]\/)\/+/g, '$1');
        this.prismeTokenEndpoint = this.prismeTokenEndpoint.replace(/([^:]\/)\/+/g, '$1');
        this.prismeKeysEndpoint = this.prismeKeysEndpoint.replace(/([^:]\/)\/+/g, '$1');
        this.prismeUserEndpoint = this.prismeUserEndpoint.replace(/([^:]\/)\/+/g, '$1');
    }
}

const CLE_STOCKAGE = new InjectionToken('CLE_STOCKAGE');
const UTILISER_LOCAL_STORAGE_TOKEN = new InjectionToken('UTILISER_LOCAL_STORAGE_TOKEN');
class PrismeAngularInitConfig {
    constructor(cleStockage, utiliserLocalStorageToken) {
        if (cleStockage) {
            this.setCleStockage(cleStockage);
        }
        else {
            this.setCleStockage('defaultPrismeStorageKey');
        }
        if (utiliserLocalStorageToken) {
            this.utiliserLocalStorage = utiliserLocalStorageToken;
        }
        else {
            this.utiliserLocalStorage = false;
        }
    }
    setCleStockage(idCleStockage) {
        this.idCleStockage = idCleStockage;
        this.cleStockageInfosUtilisateur = this.idCleStockage + '_User';
        this.cleStockageDernierNonce = this.idCleStockage + '_Nonce';
        this.cleStockageDernierState = this.idCleStockage + '_LastState';
        this.cleStockageStateUtilise = this.idCleStockage + '_UsedState';
        this.cleStockageEtatRafraichissement = this.idCleStockage + '_RefreshState';
        this.cleStockagePageFrom = this.idCleStockage + '_PageFrom';
    }
}
PrismeAngularInitConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PrismeAngularInitConfig, deps: [{ token: CLE_STOCKAGE }, { token: UTILISER_LOCAL_STORAGE_TOKEN }], target: i0.ɵɵFactoryTarget.Injectable });
PrismeAngularInitConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PrismeAngularInitConfig });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PrismeAngularInitConfig, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [CLE_STOCKAGE]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [UTILISER_LOCAL_STORAGE_TOKEN]
                }] }]; } });

class CallbackComponent {
    constructor(environment, prismeAngularInitConfig, router) {
        this.environment = environment;
        this.prismeAngularInitConfig = prismeAngularInitConfig;
        this.router = router;
    }
    ngOnInit() {
        // Récupération du paramètre pageFrom dans le sessionStorage (le pageFrom n'est pas présent lorsqu'on provient d'un portail)
        const pageFrom = sessionStorage.getItem(this.prismeAngularInitConfig.cleStockagePageFrom);
        // Si pageFrom est null alors on provient d'un portail --> pas besoin de redirection
        if (pageFrom) {
            // Redirection vers la page pageFrom
            this.router.navigate([pageFrom]);
        }
    }
}
CallbackComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: CallbackComponent, deps: [{ token: PrismeAngularConfiguration }, { token: PrismeAngularInitConfig }, { token: i3.Router }], target: i0.ɵɵFactoryTarget.Component });
CallbackComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.1.0", type: CallbackComponent, selector: "lib-callback", ngImport: i0, template: "<p>\n   R&eacute;cup&eacute;ration des infos de connexion en cours...\n</p>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: CallbackComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-callback', template: "<p>\n   R&eacute;cup&eacute;ration des infos de connexion en cours...\n</p>\n" }]
        }], ctorParameters: function () { return [{ type: PrismeAngularConfiguration }, { type: PrismeAngularInitConfig }, { type: i3.Router }]; } });

class OauthService {
    constructor(environment, prismeAngularInitConfig, router) {
        this.environment = environment;
        this.prismeAngularInitConfig = prismeAngularInitConfig;
        this.router = router;
        /** Chaines spécifiques à OIDC */
        this.response_type = 'token id_token';
        this.grant_type_jwt = 'urn:ietf:params:oauth:grant-type:jwt-bearer';
        this.assertion_type_jwt = 'jwt_token';
        this.grant_type_ocean = 'ocean_bearer';
        this.assertion_type_ocean = 'ocean_token';
    }
    savePageFrom(url) {
        sessionStorage.setItem(this.prismeAngularInitConfig.cleStockagePageFrom, url);
    }
    /**
     * Renvoie l'URL vers la mire de login pour authentification
     */
    authentificationFrontUrl(url) {
        this.savePageFrom(url);
        const response_type = encodeURIComponent(this.response_type);
        const redirect_uri = encodeURIComponent(this.environment.applicationUri + '/retour_pss');
        const scope = encodeURIComponent(this.environment.prismeScopeFront);
        const client_id = this.environment.prismeCodeApp;
        const nonce = encodeURIComponent(this.randomString(OauthService.NONCE_LENGTH));
        const state = encodeURIComponent(this.randomString(OauthService.STATE_LENGTH));
        sessionStorage.setItem(this.prismeAngularInitConfig.cleStockageDernierNonce, nonce);
        sessionStorage.setItem(this.prismeAngularInitConfig.cleStockageDernierState, state);
        // Construction de l'URL vers la mire de login
        const url_endpointLogin = this.environment.prismeAuthzEndpoint;
        return url_endpointLogin + '?response_type=' + response_type
            + '&client_id=' + client_id
            + '&redirect_uri=' + redirect_uri
            + '&scope=' + scope
            + '&nonce=' + nonce
            + '&state=' + state;
    }
    /**
     * Renvoie un body de requête en mode assertion JWT
     * @param assertion Jeton
     */
    authentificationBackAssertionJwt(assertion) {
        const jwtRequestBody = {};
        jwtRequestBody.grant_type = this.grant_type_jwt;
        jwtRequestBody.client_id = this.environment.prismeClientId;
        jwtRequestBody.client_secret = this.environment.prismeClientSecret;
        jwtRequestBody.assertion_type = this.assertion_type_jwt;
        jwtRequestBody.assertion = assertion;
        // Le scope doit etre compressé puis encodé en base 64
        const compressed_scope = pako.gzip(this.environment.prismeScopeBack, { to: 'string' });
        jwtRequestBody.scope = btoa(compressed_scope);
        return jwtRequestBody;
    }
    /**
   * Renvoie un body de requête en mode assertion JWT
   * @param assertion Jeton
   */
    authentificationFrontAssertionOcean(assertion) {
        const jwtRequestBody = {};
        jwtRequestBody.grant_type = this.grant_type_ocean;
        jwtRequestBody.client_id = this.environment.prismeClientId;
        jwtRequestBody.client_secret = this.environment.prismeClientSecret;
        jwtRequestBody.assertion_type = this.assertion_type_ocean;
        jwtRequestBody.assertion = assertion;
        // Le scope doit etre compressé puis encodé en base 64
        const compressed_scope = pako.gzip(this.environment.prismeScopeFront, { to: 'string' });
        jwtRequestBody.scope = btoa(compressed_scope);
        return jwtRequestBody;
    }
    /**
     * Récupère la dernière valeur du Nonce.
     */
    getLastNonce() {
        return sessionStorage.getItem(this.prismeAngularInitConfig.cleStockageDernierNonce);
    }
    /**
     * Récupère la dernière valeur du state.
     */
    getLastState() {
        return sessionStorage.getItem(this.prismeAngularInitConfig.cleStockageDernierState);
    }
    /**
     * Génère une chaine aléatoire pour le nonce/state
     * @param length Longueur
     */
    randomString(length) {
        let text = '';
        const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
        for (let i = 0; i < length; i++) {
            text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
    }
    /**
     * Vérifie s'il s'agit d'une ouverture en mode connexion WebMessaging
     * @param fragmentValue Valeur d'URL Fragment
     */
    isDelegatedOpeningWithWebMessage(fragmentValue) {
        return this.environment.waitWebMessageURLFragment === fragmentValue;
    }
}
OauthService.NONCE_LENGTH = 50;
OauthService.STATE_LENGTH = 50;
OauthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: OauthService, deps: [{ token: PrismeAngularConfiguration }, { token: PrismeAngularInitConfig }, { token: i3.Router }], target: i0.ɵɵFactoryTarget.Injectable });
OauthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: OauthService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: OauthService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: PrismeAngularConfiguration, decorators: [{
                    type: Inject,
                    args: [PrismeAngularConfiguration]
                }] }, { type: PrismeAngularInitConfig }, { type: i3.Router }]; } });

/**
 * Permet d'acceder aux donnée fournie par le service user-info
 */
class InfosUtilisateur {
    constructor(data) {
        this.dataInfosUtilisateur = data;
    }
    getNom() {
        return this.dataInfosUtilisateur.auser_sn;
    }
    getPrenom() {
        return this.dataInfosUtilisateur.auser_givenname;
    }
    /**
     * Retourne uen chaine contenant le prénom et le nom de l'utilisateur
     */
    getNomComplet() {
        return this.dataInfosUtilisateur.auser_cn;
    }
    getCodeAgent() {
        return this.dataInfosUtilisateur.auser_uid;
    }
    getIdSnv2() {
        return this.dataInfosUtilisateur.auser_idsnv2;
    }
    getCodeOrganisme() {
        return this.dataInfosUtilisateur.auser_codeorg;
    }
    getInterRegion() {
        return this.dataInfosUtilisateur.auser_ircode;
    }
    getAdresseMail() {
        return this.dataInfosUtilisateur.auser_mail;
    }
    getVille() {
        return this.dataInfosUtilisateur.auser_persnomville;
    }
    getAdresseEtablissement() {
        return this.dataInfosUtilisateur.auser_etabaddr;
    }
    /**
     * Retourne la liste des droits de l'utilisateur
     */
    getDroits() {
        return this.dataInfosUtilisateur.access;
    }
    /**
     * Retourne les données fournie par le service user-info en JSon
     */
    getDataInfosUtilisateur() {
        return this.dataInfosUtilisateur;
    }
}

/**
 * Service permettant de décoder un access token et d'en extraire les informations
 */
class AccessTokenService {
    constructor() {
        this.jwtHelper = new JwtHelperService();
    }
    getIdentifiantUtilisateur(accessToken) {
        return this.decodeAccessToken(accessToken).sub.split('@')[0];
    }
    getDroitsUtilisateur(accessToken) {
        // La liste des droits est située dans le "aud" du jeton d'accès au format base64
        const decode_aud = atob(this.decodeAccessToken(accessToken).aud);
        // Après décodage, la chaine est gzippée : utilisation de la bibliothèque pako pour décompresser
        const droits_string = pako.inflate(decode_aud, { to: 'string' });
        // Les droits FRONT sont séparés par un espace
        return droits_string.split(' ');
    }
    decodeAccessToken(accessToken) {
        return this.jwtHelper.decodeToken(accessToken);
    }
    getTokenExpirationDate(accessToken) {
        return this.jwtHelper.getTokenExpirationDate(accessToken);
    }
    isTokenExpired(accessToken) {
        return this.jwtHelper.isTokenExpired(accessToken);
    }
}
AccessTokenService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: AccessTokenService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
AccessTokenService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: AccessTokenService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: AccessTokenService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

class LoginService {
    constructor(config, accessTokenService) {
        this.config = config;
        this.accessTokenService = accessTokenService;
    }
    /**
     * Indique si l'utilisateur est connecté.
     */
    isConnecte() {
        const logInfo = this.getInfos();
        return logInfo !== null && logInfo.accessTokenBack !== null;
    }
    /**
     * Renvoie toutes les informations
     */
    getInfos() {
        const infos = this.getStorage().getItem(this.config.cleStockageInfosUtilisateur);
        if (infos === null) {
            return null;
        }
        return JSON.parse(infos);
    }
    /**
     * Renvoie les infos de l'utilisateur
     */
    getInfosUtilisateurBack() {
        const infos = this.getInfos();
        if (infos != null && infos.infosUtilisateurBack != null) {
            return new InfosUtilisateur(infos.infosUtilisateurBack);
        }
        return null;
    }
    getInfosUtilisateurFront() {
        const infos = this.getInfos();
        if (infos != null && infos.infosUtilisateurFront != null) {
            return new InfosUtilisateur(infos.infosUtilisateurFront);
        }
        return null;
    }
    /**
     * Renvoie le payload
     */
    getPayload() {
        const infos = this.getInfos();
        if (infos === null) {
            return null;
        }
        return infos.payload;
    }
    /**
     * Renvoie les droits de l'utilisateur pour le frontend
     */
    getDroitsUtilisateur() {
        const sessionUtilisateur = this.getInfos();
        if (sessionUtilisateur === null) {
            return null;
        }
        return this.accessTokenService.getDroitsUtilisateur(sessionUtilisateur.accessTokenFront);
    }
    /**
     * Renvoie les droits de l'utilisateur pour le backend
     */
    getDroitsUtilisateurBack() {
        const sessionUtilisateur = this.getInfos();
        if (sessionUtilisateur === null) {
            return null;
        }
        return this.accessTokenService.getDroitsUtilisateur(sessionUtilisateur.accessTokenBack);
    }
    getAccessTokenBack() {
        const infos = this.getInfos();
        if (infos === null) {
            return null;
        }
        return infos.accessTokenBack;
    }
    getAccessTokenFront() {
        const infos = this.getInfos();
        if (infos === null) {
            return null;
        }
        return infos.accessTokenFront;
    }
    getOceanToken() {
        const infos = this.getInfos();
        if (infos === null) {
            return null;
        }
        return infos.oceanToken;
    }
    getMode() {
        const infos = this.getInfos();
        if (infos === null) {
            return null;
        }
        return infos.mode;
    }
    /**
     * Enregistre les infos utilisateur
     * @param infos Jeton
     */
    storeInfos(infos) {
        // On récupère le payload existant
        let oldinfos;
        oldinfos = JSON.parse(this.getStorage().getItem(this.config.cleStockageInfosUtilisateur));
        if (oldinfos && infos) {
            infos.payload = infos.payload || oldinfos.payload;
        }
        this.getStorage().setItem(this.config.cleStockageInfosUtilisateur, JSON.stringify(infos));
    }
    /**
     * Pour le mode portail, permet de mettre à jour l'access token dans les infos utilisateur.
     * @param accessToken Jeton
     * @param expiration Date
     */
    updateAccessToken(accessToken, expiration) {
        const infos = this.getInfos();
        if (infos !== null) {
            infos.accessTokenBack = accessToken;
            infos.expiration = expiration;
        }
        this.storeInfos(infos);
    }
    /**
     * Permet de mettre à jour les infos utilisateur.
     * @param infosUtilisateur les infos utilisateur à mettre à jour
     */
    updateInfosUtilisateurBack(infosUtilisateur) {
        const infos = this.getInfos();
        if (infos !== null) {
            infos.infosUtilisateurBack = infosUtilisateur;
            this.storeInfos(infos);
        }
    }
    /**
     * Permet de mettre à jour les infos utilisateur.
     * @param infosUtilisateur les infos utilisateur à mettre à jour
     */
    updateInfosUtilisateurFront(infosUtilisateur) {
        const infos = this.getInfos();
        if (infos !== null) {
            infos.infosUtilisateurFront = infosUtilisateur;
            this.storeInfos(infos);
        }
    }
    getIdentifiantUtilisateur() {
        const sessionUtilisateur = this.getInfos();
        return this.accessTokenService.getIdentifiantUtilisateur(sessionUtilisateur.accessTokenFront);
    }
    /**
   * Permet de mettre à jour le payload
   * @param payload a mettre à jour
   */
    updatePayload(payload) {
        const infos = this.getInfos();
        if (infos !== null) {
            infos.payload = payload;
            this.storeInfos(infos);
        }
    }
    /**
     * Controle si les données utilisateur contiennent bien les droits demandés
     * @param droits Liste des droits
     */
    estAutorise(droits) {
        return this.checkAutorisation(droits, this.getDroitsUtilisateur());
    }
    /**
     * Controle si les données utilisateur contiennent bien les droits demandés pour le backend
     * @param droits Liste des droits
     */
    estAutoriseBack(droits) {
        return this.checkAutorisation(droits, this.getDroitsUtilisateurBack());
    }
    checkAutorisation(droits, droitsJeton) {
        if (!this.isConnecte()) {
            return false;
        }
        for (const droit of droits) {
            if (this.controleAutorisation(droit, droitsJeton)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Controle si les données utilisateur contiennent bien le droit spécifique demandé
     * On considère que les droits sont de la forme <perimetre>:<application>:<profil>
     * @param droit Droit
     * @param droitsJeton la liste des droits contenu dans le jeton
     */
    controleAutorisation(droit, droitsJeton) {
        if (!droitsJeton) {
            return false;
        }
        // Si la chaine <perimetre>:<application>:<profil> contient le droit, alors l'utilisateur est autorisé
        for (const droitJeton of droitsJeton) {
            const values = droitJeton.split(':');
            if (values && -1 !== values.indexOf(droit)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Déconnecter
     * @returns Promise<any> renvoi resolve(true) lorsque la déconnexion est terminée
     */
    deconnecter() {
        return new Promise((resolve, reject) => {
            this.getStorage().clear();
            localStorage.clear();
            resolve(true);
        });
    }
    getStorage() {
        if (this.config.utiliserLocalStorage) {
            return localStorage;
        }
        return sessionStorage;
    }
}
LoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: LoginService, deps: [{ token: PrismeAngularInitConfig }, { token: AccessTokenService }], target: i0.ɵɵFactoryTarget.Injectable });
LoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: LoginService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: LoginService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: PrismeAngularInitConfig, decorators: [{
                    type: Inject,
                    args: [PrismeAngularInitConfig]
                }] }, { type: AccessTokenService }]; } });

class OauthValidationService {
    constructor(environment) {
        this.environment = environment;
    }
    /**
     * Valider que le champ "iss" du token correspond bien au provider
     * "Malicious compliance" vis à vis du guide développeur
     * @param token Jeton
     */
    validerIss(token) {
        return token.iss === this.environment.prismeIss;
    }
    /**
     * Valider que le champ "exp" du token ne correspond pas à une date passée
     * @param token Jeton
     */
    validerExp(token) {
        // Construire un objet Date qui contient la date d'expiration du jeton
        const dateExp = new Date(0);
        dateExp.setUTCSeconds(token.exp);
        if (!dateExp) {
            return false;
        }
        // Comparer la date d'expiration à la date courante
        return dateExp.valueOf() > new Date().valueOf();
    }
    /**
     * Valider que le token est correctement signé
     * @param token Jeton
     * @param keys Cles
     * @param alg Algorithme
     */
    validerSignature(token, keys, alg) {
        // Récupérer le header du jeton
        const header_jeton_encode = token.split('.')[0];
        const header_decode = JSON.parse(atob(header_jeton_encode));
        // L'algorithme doit etre R256
        if (header_decode.alg !== alg) {
            return false;
        }
        let resultat = false;
        // Si une seule clé présente, pas de controle du kid
        if (keys.length === 1) {
            const key = keys[0];
            const clePublique = jsrsasign.KEYUTIL.getKey(key);
            resultat = jsrsasign.KJUR.jws.JWS.verify(token, clePublique, [alg]);
            return resultat;
        }
        // Comparaison de chaque clé à la clé fournie dans le jeton
        for (const key of keys) {
            if (key.kid === header_decode.kid) {
                const clePublique = jsrsasign.KEYUTIL.getKey(key);
                resultat = jsrsasign.KJUR.jws.JWS.verify(token, clePublique, [alg]);
                return resultat;
            }
        }
        return resultat;
    }
    /**
     * Valider que le champ "aud" du token n'est pas vide
     * @param token Jeton
     */
    validerAudNonVide(token) {
        return token.aud && token.aud.length > 0;
    }
    /**
   * Valider que le champ "sub" du token est égal au sujet + '@' + le client ID requis
   * @param token Jeton
   * @param sujet Sujet
   * @param client_id Identifiant
   */
    validerSubOcean(token, client_id) {
        const sub = token.sub.split('@');
        return sub.length === 2 && sub[1] === client_id;
    }
}
OauthValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: OauthValidationService, deps: [{ token: PrismeAngularConfiguration }], target: i0.ɵɵFactoryTarget.Injectable });
OauthValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: OauthValidationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: OauthValidationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: PrismeAngularConfiguration, decorators: [{
                    type: Inject,
                    args: [PrismeAngularConfiguration]
                }] }]; } });

const ALGO_VALIDATION = 'RS512';
class OauthCallbackService {
    constructor(environment, oauthService, loginService, oauthValidationService, http, accessTokenService) {
        this.environment = environment;
        this.oauthService = oauthService;
        this.loginService = loginService;
        this.oauthValidationService = oauthValidationService;
        this.http = http;
        this.accessTokenService = accessTokenService;
    }
    handleFragment(fragment, callBackSucces, callBackErreur) {
        // Parsing du fragment (séparation des champs)
        const champs = decodeURIComponent(fragment).split('&');
        const params = [];
        champs.forEach(function (value) {
            // Parsing des champs du fragment
            if (value.indexOf('=') !== -1) {
                const champ_tokens = value.split('=');
                params[champ_tokens[0]] = champ_tokens[1];
            }
        });
        // Récupération Access Token
        const access_token_str = params['access_token'];
        const ocean_token_str = params['data'];
        // Si tout s'est bien passé, on a l'un des 2 jetons
        if (access_token_str) {
            const state = params['state'];
            let mode_authentification = '';
            if (state) {
                // si on a un state alors on est dans la cynématique implicit
                // Voir OauthService.authentificationFrontUrl
                mode_authentification = 'implicit';
                // Si le fragment vient de la mire PSS alors on peut le valider
                if (state !== this.oauthService.getLastState()) {
                    console.error('State invalide, il ne correspond pas à la requête.');
                    callBackErreur();
                    return Promise.reject(new Error('StateInvalid'));
                }
            }
            else {
                mode_authentification = 'portail';
            }
            return this.handleAccessToken(access_token_str, mode_authentification, callBackSucces, callBackErreur);
        }
        else if (ocean_token_str) {
            return this.handleJetonOcean(ocean_token_str, callBackSucces, callBackErreur);
        }
        else {
            // Sinon il y a eu une erreur
            console.error('Erreur pendant la récupération du jeton d\'accès FRONT depuis le portail : jeton non trouvé');
            callBackErreur();
        }
    }
    handleAccessToken(access_token_front_str, mode_authentification, callBackSucces, callBackErreur) {
        return new Promise((resolve, reject) => {
            const headers = new HttpHeaders();
            headers.append('Content-type', 'application/json');
            const options = { headers: headers };
            let identifiantUtilisateur = '';
            try {
                identifiantUtilisateur = this.accessTokenService.getIdentifiantUtilisateur(access_token_front_str);
            }
            catch (err) {
                // Traitement en cas d'erreur decodage du jeton
                callBackErreur();
                reject(err);
            }
            // Validation du jeton - Récupération des clés
            this.http.get(this.environment.prismeKeysEndpoint).subscribe((keysResult) => {
                this.pssPublicKeys = keysResult.keys;
                // On peut maintenant échanger le jeton FRONT contre un jeton BACK
                this.http.post(this.environment.prismeTokenEndpoint, this.oauthService.authentificationBackAssertionJwt(access_token_front_str), options).subscribe((body) => {
                    // Récupération du jeton
                    const access_token_back_str = body.access_token;
                    // Validation
                    if (!this.validateJeton(access_token_back_str, this.pssPublicKeys)) {
                        callBackErreur();
                        resolve('erreur');
                        return;
                    }
                    // Mise à jour de la valeur d'expiration
                    const expirationTime = this.calculateExpirationTime(body.expires_in);
                    const tokenData = {
                        accessTokenBack: access_token_back_str,
                        accessTokenFront: access_token_front_str,
                        oceanToken: null,
                        expiration: expirationTime,
                        infosUtilisateurFront: null,
                        infosUtilisateurBack: null,
                        mode: mode_authentification,
                        payload: null
                    };
                    this.loginService.storeInfos(tokenData);
                    // Appel du service user-infos pour avoir les infos utilisateur bak
                    this.updateInfosUtilisateur(identifiantUtilisateur, callBackSucces, callBackErreur, resolve);
                }, (err) => {
                    console.error('Erreur pendant l\'authentification : échec du JWT Assertion');
                    if (err.error) {
                        console.error('[ ' + err.error.error_code + ' ] ' + err.error.error_message);
                    }
                    callBackErreur();
                    resolve('erreur');
                });
            }, (err) => {
                console.error('Erreur lors de la récupération des clés publiques PSS');
                console.error(err);
                callBackErreur();
                resolve('erreur');
            });
        });
    }
    /**
     * Traitement du jeton
     * @param ocean_token_str Jeton
     * @param callBackSucces Méthode si traitement OK
     * @param callBackErreur Méthode si traitement KO
     */
    handleJetonOcean(ocean_token_str, callBackSucces, callBackErreur) {
        return new Promise((resolve, reject) => {
            /** On l'échange contre un jeton front */
            const headers = new HttpHeaders();
            headers.append('Content-type', 'application/json');
            const options = { headers: headers };
            this.http.post(this.environment.prismeTokenEndpoint, this.oauthService.authentificationFrontAssertionOcean(ocean_token_str), options).subscribe((bodyFront) => {
                // Récupération du jeton
                const access_token_front_str = bodyFront.access_token;
                const access_token_front_decode = this.accessTokenService.decodeAccessToken(access_token_front_str);
                // Validation du jeton - Récupération des clés
                this.http.get(this.environment.prismeKeysEndpoint).subscribe((keysResult) => {
                    this.pssPublicKeys = keysResult.keys;
                    // Validation du jeton
                    if (!this.validateJeton(access_token_front_str, this.pssPublicKeys)) {
                        callBackErreur();
                        resolve('erreur');
                        return;
                    }
                    if (!this.oauthValidationService.validerSubOcean(access_token_front_decode, this.environment.prismeClientId)) {
                        console.error('Contrôle du jeton d\'accès FRONT : SUB non valide');
                        callBackErreur();
                        resolve('erreur');
                        return;
                    }
                    // On peut maintenant échanger le jeton FRONT contre un jeton BACK
                    this.http.post(this.environment.prismeTokenEndpoint, this.oauthService.authentificationBackAssertionJwt(access_token_front_str), options).subscribe((bodyBack) => {
                        // Récupération du jeton
                        const access_token_back_str = bodyBack.access_token;
                        // Validation du jeton
                        if (!this.validateJeton(access_token_back_str, this.pssPublicKeys)) {
                            callBackErreur();
                            resolve('erreur');
                            return;
                        }
                        // Mise à jour de la valeur d'expiration
                        const expirationTime = this.calculateExpirationTime(bodyBack.expires_in);
                        // Login
                        const tokenData = {
                            accessTokenBack: access_token_back_str,
                            accessTokenFront: access_token_front_str,
                            oceanToken: ocean_token_str,
                            expiration: expirationTime,
                            infosUtilisateurFront: null,
                            infosUtilisateurBack: null,
                            mode: 'ocean',
                            payload: null
                        };
                        this.loginService.storeInfos(tokenData);
                        // Appel du service user-infos pour avoir les infos utilisateur
                        const identifiantUtilisateur = this.accessTokenService.getIdentifiantUtilisateur(access_token_front_str);
                        this.updateInfosUtilisateur(identifiantUtilisateur, callBackSucces, callBackErreur, resolve);
                    }, (err) => {
                        console.error('Erreur pendant l\'authentification : échec du JWT Assertion');
                        if (err.error_message) {
                            console.error('[ ' + err.error_code + ' ] ' + err.error_message);
                        }
                        callBackErreur();
                        resolve('erreur');
                    });
                }, (err) => {
                    console.error('Erreur lors de la récupération des clés publiques PSS');
                    console.error(err);
                    callBackErreur();
                    resolve('erreur');
                });
            }, (err) => {
                console.error('Erreur HTTP');
                console.error(err);
                callBackErreur();
                resolve('erreur');
            });
        });
    }
    /**
     * Méthode de renovellement d'un jeton
     * @param access_token_front_str le jeton à renouveller
     */
    renewAccessTokenPortail(access_token_front_str) {
        return new Promise((resolve, reject) => {
            if (this.pssPublicKeys) {
                this.renewAccessToken(access_token_front_str, this.pssPublicKeys, resolve, reject);
            }
            else {
                // Récupération des clés pour valider le jeton
                this.http.get(this.environment.prismeKeysEndpoint).subscribe((keysResult) => {
                    this.pssPublicKeys = keysResult.keys;
                    this.renewAccessToken(access_token_front_str, this.pssPublicKeys, resolve, reject);
                }, (err) => {
                    console.error('Erreur lors de la récupération des clés publiques PSS');
                    console.error(err);
                    // Rejet de la promise pour stopper le rafraichissement car on a une erreur
                    reject(err);
                });
            }
        });
    }
    /**
     * Méthode de renovellement d'un jeton
     * @param access_token_front_str  le jeton à renouveller
     * @param publicKeys les clés pour valider le jeton
     * @param resolve méthode pour indiquer que le renouvellement est terminé
     * @param reject méthode pour indiquer qu'une erreur est survenue lors du renouvellement
     */
    renewAccessToken(access_token_front_str, publicKeys, resolve, reject) {
        // On peut maintenant échanger le jeton FRONT contre un jeton BACK
        const headers = new HttpHeaders();
        headers.append('Content-type', 'application/json');
        const options = { headers: headers };
        this.http.post(this.environment.prismeTokenEndpoint, this.oauthService.authentificationBackAssertionJwt(access_token_front_str), options).subscribe((body) => {
            // Récupération du jeton
            const access_token_back_str = body.access_token;
            // Validation
            if (!this.validateJeton(access_token_back_str, publicKeys)) {
                reject('jeton invalide');
            }
            // Mise à jour de la valeur d'expiration
            const expirationTime = this.calculateExpirationTime(body.expires_in);
            this.loginService.updateAccessToken(access_token_back_str, expirationTime);
            // Resolve de la promise pour indiquer que le refresh est ok
            resolve(true);
        }, (err) => {
            console.error('Erreur pendant l\'authentification : échec du JWT Assertion');
            if (err.error) {
                console.error('[ ' + err.error.error_code + ' ] ' + err.error.error_message);
            }
            // Rejet de la promise pour stopper le rafraichissement car on a une erreur
            reject(err);
        });
    }
    /**
     * Validation du jeton : voir la documentation JWT Assertion
     * @param access_token_back_str le jeton
     * @param access_token_back_decode le jeton décodé
     * @param publicKeys les clés
     */
    validateJeton(access_token_back_str, publicKeys) {
        const access_token_back_decode = this.accessTokenService.decodeAccessToken(access_token_back_str);
        // Validation du jeton : voir la documentation JWT Assertion
        if (!this.oauthValidationService.validerIss(access_token_back_decode)) {
            console.error('Contrôle du jeton d\'accès : ISS non valide');
            return false;
        }
        if (!this.oauthValidationService.validerExp(access_token_back_decode)) {
            console.error('Contrôle du jeton d\'accès : EXP non valide');
            return false;
        }
        if (!this.oauthValidationService.validerAudNonVide(access_token_back_decode)) {
            console.error('Contrôle du jeton d\'accès : AUD non valide');
            return false;
        }
        if (!this.oauthValidationService.validerSignature(access_token_back_str, publicKeys, ALGO_VALIDATION)) {
            console.error('Contrôle du jeton d\'accès : Signature non valide');
            return false;
        }
        return true;
    }
    /**
     * calcule la date d'expiration du jeton
     * @param expiresInNum la durée de validité du jeton
     */
    calculateExpirationTime(expiresInNum) {
        const expirationDate = new Date();
        expirationDate.setSeconds(expirationDate.getSeconds() + expiresInNum);
        return expirationDate;
    }
    /**
     * Met à jour les données utilisateur en utilisateur le service user-infos
     * @param identifiantUtilisateur le user
     * @param callBackSucces le callback si tout est ok
     * @param callBackErreur le callback d'erreur
     * @param resolve provient de la promise retournée par ce service OauthCallbackService
     */
    updateInfosUtilisateur(identifiantUtilisateur, callBackSucces, callBackErreur, resolve) {
        if (this.environment.chargerUserInfosBack) {
            this.getUserInfoObservable(identifiantUtilisateur, this.loginService.getAccessTokenBack()).subscribe(bodyUser => {
                this.loginService.updateInfosUtilisateurBack(bodyUser);
                if (this.environment.chargerUserInfosFront) {
                    this.updateInfosUtilisateurFront(identifiantUtilisateur, callBackSucces, callBackErreur, resolve);
                }
                else {
                    callBackSucces();
                    resolve('sucess');
                }
            }, err => this.handlerUserInfoError(err, callBackErreur, resolve));
        }
        else if (this.environment.chargerUserInfosFront) {
            this.updateInfosUtilisateurFront(identifiantUtilisateur, callBackSucces, callBackErreur, resolve);
        }
        else {
            callBackSucces();
            resolve('sucess');
        }
    }
    /**
     * Permet de réaliser un appel à user-info avec uun access token front et de mettre à jour les informations utilisateur
     * @param identifiantUtilisateur le user
     * @param callBackSucces le callback si tout est ok
     * @param callBackErreur le callback d'erreur
     * @param resolve provient de la promise retournée par ce service OauthCallbackService
     */
    updateInfosUtilisateurFront(identifiantUtilisateur, callBackSucces, callBackErreur, resolve) {
        this.getUserInfoObservable(identifiantUtilisateur, this.loginService.getAccessTokenFront()).subscribe(result => {
            this.loginService.updateInfosUtilisateurFront(result);
            callBackSucces();
            resolve('sucess');
        }, err => this.handlerUserInfoError(err, callBackErreur, resolve));
    }
    /**
     * Permet de réaliser l'appel au service user-ifnos
     * @param identifiantUtilisateur le user
     * @param token le token d'authentification
     */
    getUserInfoObservable(identifiantUtilisateur, token) {
        const requestHeaders = {
            headers: new HttpHeaders({
                'Content-type': 'application/json',
                'Authorization': 'Bearer ' + token
            })
        };
        return this.http.post(this.environment.prismeUserEndpoint, { 'username': identifiantUtilisateur }, requestHeaders);
    }
    /**
     * Permet de gérer les messages d'erreurs du service user-infos
     * @param err le message de retour du service
     * @param callBackErreur le callback d'erreur
     * @param resolve provient de la promise retournée par ce service OauthCallbackService
     */
    handlerUserInfoError(err, callBackErreur, resolve) {
        console.error('Erreur pendant l\'authentification : échec du user-info');
        if (err.error) {
            console.error('[ ' + err.error.error_code + ' ] ' + err.error.error_message);
        }
        callBackErreur();
        resolve('erreur');
    }
}
OauthCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: OauthCallbackService, deps: [{ token: PrismeAngularConfiguration }, { token: OauthService }, { token: LoginService }, { token: OauthValidationService }, { token: i4.HttpClient }, { token: AccessTokenService }], target: i0.ɵɵFactoryTarget.Injectable });
OauthCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: OauthCallbackService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: OauthCallbackService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: PrismeAngularConfiguration, decorators: [{
                    type: Inject,
                    args: [PrismeAngularConfiguration]
                }] }, { type: OauthService }, { type: LoginService }, { type: OauthValidationService }, { type: i4.HttpClient }, { type: AccessTokenService }]; } });

class RefreshService {
    constructor(environment, oauthCallbackService, loginService, prismeAngularInitConfig) {
        this.environment = environment;
        this.oauthCallbackService = oauthCallbackService;
        this.loginService = loginService;
        this.prismeAngularInitConfig = prismeAngularInitConfig;
        this.timerSubject = new Subject();
    }
    initierRafraichissement() {
        // on s'assure que le rafraichissement ne se lance pas plusieurs fois
        this.stopperRafraichissement();
        sessionStorage.setItem(this.prismeAngularInitConfig.cleStockageEtatRafraichissement, 'O');
        this.lancerTimerRafraichissement();
    }
    /**
     * Permet de relancer rafraichissement
     * Ex : lors d'un F5 sur la page le timer est détruit
     */
    relancerRafraichissement() {
        const etatRafraichissement = sessionStorage.getItem(this.prismeAngularInitConfig.cleStockageEtatRafraichissement);
        if (etatRafraichissement === 'O' && !this.timerSubscription) {
            this.lancerTimerRafraichissement();
        }
    }
    /**
     * Création du timer qui va rafraichir le jeton au bout d'un temps donné
     */
    lancerTimerRafraichissement() {
        this.timerSubscription = timer(this.environment.prismeRefreshTokensInterval, this.environment.prismeRefreshTokensInterval)
            .pipe(takeUntil(this.timerSubject))
            .subscribe(() => {
            this.rafraichir();
        });
    }
    /**
     * Rafraichissement effectif du jeton selon le mode de connexion.
     * En cas d'erreur on arrête le service
     */
    rafraichir() {
        if (sessionStorage.getItem(this.prismeAngularInitConfig.cleStockageEtatRafraichissement) === 'O') {
            const accessToken = this.loginService.getAccessTokenBack();
            if (accessToken !== null) {
                this.oauthCallbackService.renewAccessTokenPortail(accessToken).catch(error => {
                    console.error('error refresh jeton : ' + JSON.stringify(error));
                    this.stopperRafraichissement();
                });
            }
        }
    }
    /**
     * Permet de stopper le rafraichissement du jeton
     * @returns Promise<any> renvoi resolve(true) lorsque le service est arreté
     */
    stopperRafraichissement() {
        return new Promise((resolve, reject) => {
            sessionStorage.setItem(this.prismeAngularInitConfig.cleStockageEtatRafraichissement, 'N');
            // arrêt du timer
            this.timerSubject.next();
            if (this.timerSubscription) {
                this.timerSubscription.unsubscribe();
            }
            resolve(true);
        });
    }
    /**
     * Permet de stopper le rafraichissement du jeton et de se deconnecter
     * Cette méthode contient les appels à
     *  RefreshService.stopperRafraichissement() et LoginService.deconnecter()
     * @returns Promise<any> renvoi resolve(true) lorsque les opérations sont terminées
     */
    stopperRafraichissementEtDeconnecter() {
        return new Promise((resolve, reject) => {
            this.stopperRafraichissement().then(() => {
                this.loginService.deconnecter().then(() => {
                    resolve(true);
                });
            });
        });
    }
}
RefreshService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: RefreshService, deps: [{ token: PrismeAngularConfiguration }, { token: OauthCallbackService }, { token: LoginService }, { token: PrismeAngularInitConfig }], target: i0.ɵɵFactoryTarget.Injectable });
RefreshService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: RefreshService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: RefreshService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: PrismeAngularConfiguration, decorators: [{
                    type: Inject,
                    args: [PrismeAngularConfiguration]
                }] }, { type: OauthCallbackService }, { type: LoginService }, { type: PrismeAngularInitConfig }]; } });

class AuthImplicitGuard {
    constructor(successLH, failureLH, environment, oauthService, loginService, oauthCallBackService, refreshService, _ngZone) {
        this.environment = environment;
        this.oauthService = oauthService;
        this.loginService = loginService;
        this.oauthCallBackService = oauthCallBackService;
        this.refreshService = refreshService;
        this._ngZone = _ngZone;
        this.successLH = successLH;
        this.failureLH = failureLH;
    }
    // Methode "GUARD" devant être résolue pour avant l'accès à une page protégée
    canActivate(route, state) {
        // En cas d'erreur, il y a des queryParams (notamment "?error=...")
        if (route.queryParams && route.queryParams['error']) {
            const error = route.queryParams['error'];
            switch (error) {
                case 'reset_password_required': {
                    // Cela signifie que l'utilisateur a cliqué sur le lien "mot de passe oublié"
                    alert('Le mot de passe de cette application est votre mot de passe Anais');
                    break;
                }
                default: {
                    // Cela signifie qu'il y a eu une erreur
                    this.failureLH.failureLogin(this.loginService);
                    return false;
                }
            }
        }
        if (this.loginService.isConnecte()) {
            this.refreshService.relancerRafraichissement();
            return true;
        }
        // Authentification directe via WebMessage
        // (un fragment spécifique présent dans l'url permet d'activer ce mode d'ouverture)
        if (this.oauthService.isDelegatedOpeningWithWebMessage(route.fragment)) {
            const result = this.connexionViaWebMessageHTML5();
            this.sendReadyWebMessageHTML5();
            return result;
        }
        // Authentification avec un fragment présent dans l'url
        if (route.fragment) {
            return this.connexionViaURLFragment(route.fragment);
        }
        // Redirection vers la mire d'authentification
        window.location.href = this.oauthService.authentificationFrontUrl(state.url);
        return false;
    }
    // Mode de connexion Cross-Domain via passage de Jeton avec usage du WebMessaging HTML5
    connexionViaWebMessageHTML5() {
        const myOauthCallBackService = this.oauthCallBackService;
        const mySuccessLH = this.successLH;
        const myFailureLH = this.failureLH;
        const myRefreshService = this.refreshService;
        const myLoginService = this.loginService;
        const myEnvironment = this.environment;
        return new Promise(function (resolve, reject) {
            // Ajout d'un listener en attente des evenements de type 'message'
            window.addEventListener('message', (e) => {
                if (e.data.topic === myEnvironment.jetonMessageTopic) {
                    const tokenValue = e.data.token_value;
                    // A la reception d'un message de type token, lancement des traitements de login
                    if (e.data.token_type === 'jwt') {
                        myOauthCallBackService.handleAccessToken(tokenValue, 'portail', () => mySuccessLH.successLogin(myRefreshService), () => myFailureLH.failureLogin(myLoginService))
                            .then(() => {
                            myRefreshService.initierRafraichissement();
                            resolve(true);
                        });
                    }
                    else if (e.data.token_type === 'ocean') {
                        myOauthCallBackService.handleJetonOcean(tokenValue, () => mySuccessLH.successLogin(myRefreshService), () => myFailureLH.failureLogin(myLoginService))
                            .then(() => {
                            myRefreshService.initierRafraichissement();
                            resolve(true);
                        });
                    }
                }
            });
        });
    }
    // Mode de connexion Cross-Domain via passage de Jeton avec usage URLFragment
    // Usage limité à des jetons <2ko pour IE
    connexionViaURLFragment(routeFragment) {
        return new Promise((resolve) => {
            this.oauthCallBackService
                .handleFragment(routeFragment, () => this.successLH.successLogin(this.refreshService), () => this.failureLH.failureLogin(this.loginService))
                .then(() => {
                this.refreshService.initierRafraichissement();
                resolve(true);
            }).catch(function () { }); // prevents "Uncaught (in promise) error
        });
    }
    sendReadyWebMessageHTML5() {
        const message = new AuthImplicitGuard.ReadyWebMessage(this.environment.jetonReadyTopic, null);
        window.parent.postMessage(message, '*');
    }
}
AuthImplicitGuard.ReadyWebMessage = class {
    constructor(aTopic, aData) {
        this.topic = aTopic;
        this.data = aData;
    }
};
AuthImplicitGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: AuthImplicitGuard, deps: [{ token: PRISME_SUCCESS_LOGIN_HANDLER }, { token: PRISME_FAILURE_LOGIN_HANDLER }, { token: PrismeAngularConfiguration }, { token: OauthService }, { token: LoginService }, { token: OauthCallbackService }, { token: RefreshService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
AuthImplicitGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: AuthImplicitGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: AuthImplicitGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [PRISME_SUCCESS_LOGIN_HANDLER]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PRISME_FAILURE_LOGIN_HANDLER]
                }] }, { type: PrismeAngularConfiguration, decorators: [{
                    type: Inject,
                    args: [PrismeAngularConfiguration]
                }] }, { type: OauthService }, { type: LoginService }, { type: OauthCallbackService }, { type: RefreshService }, { type: i0.NgZone }]; } });

/**
 * Intercepteur qui ajoute à toutes les requêtes le jeton dans l'entête Bearer
 * Ne fait rien si l'utilisateur n'est pas connecté
 */
class PrismeBearerInterceptor {
    constructor(loginService) {
        this.loginService = loginService;
    }
    intercept(req, next) {
        // Si l'utilisateur est connecté et que l'on a pas déjà un jeton ajouté au moment de la création de la requête
        if (this.loginService.isConnecte() && !this.hasBearerToken(req)) {
            // Ajout de l'access token
            return next.handle(this.ajoutJeton(req));
        }
        // Sinon, rien à faire
        return next.handle(req);
    }
    // Ajoute le jeton dans l'entête Bearer
    ajoutJeton(req) {
        const headers = {
            Authorization: 'Bearer ' + this.loginService.getAccessTokenBack()
        };
        return req.clone({ setHeaders: headers });
    }
    /**
     * Vérifie si on a déjà le jeton d'authentification dans les entêtes de la requête
     * @param req la requête http
     */
    hasBearerToken(req) {
        if (req.headers.has('Authorization')) {
            const headers = req.headers.getAll('Authorization');
            if (headers.find(value => value.startsWith('Bearer ') === true)) {
                return true;
            }
        }
        return false;
    }
}
PrismeBearerInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PrismeBearerInterceptor, deps: [{ token: LoginService }], target: i0.ɵɵFactoryTarget.Injectable });
PrismeBearerInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PrismeBearerInterceptor });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PrismeBearerInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: LoginService }]; } });

/**
 * Function permettant d'initiliser la configuration de prismeAngularInitModule
 *
 * @export
 * @param  cleStockage : clé de stockage utilisé dans le sessionStorage
 * @returns la classe PrismeAngularInitConfig instanciée
 */
/**
 * Module permettant d'initialiser la partie minimale de prisme.
 * Il permet entre d'initialiser les modules nécessaires au bearerInterceptor
 * Il prend en paramètre optionnel la clé de stockage
 * @export
 */
class PrismeAngularInitModule {
    static forRoot(cleStockage, utiliserLocalStorage) {
        return {
            ngModule: PrismeAngularInitModule,
            providers: [PrismeAngularInitConfig, { provide: CLE_STOCKAGE, useValue: cleStockage },
                { provide: UTILISER_LOCAL_STORAGE_TOKEN, useValue: utiliserLocalStorage }]
        };
    }
}
PrismeAngularInitModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PrismeAngularInitModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PrismeAngularInitModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.1.0", ngImport: i0, type: PrismeAngularInitModule, imports: [CommonModule,
        HttpClientModule,
        StorageServiceModule, i3.RouterModule] });
PrismeAngularInitModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PrismeAngularInitModule, providers: [
        { provide: HTTP_INTERCEPTORS, useClass: PrismeBearerInterceptor, multi: true },
    ], imports: [CommonModule,
        HttpClientModule,
        StorageServiceModule,
        RouterModule.forRoot([], { relativeLinkResolution: 'legacy' })] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PrismeAngularInitModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule,
                        HttpClientModule,
                        StorageServiceModule,
                        RouterModule.forRoot([], { relativeLinkResolution: 'legacy' })],
                    providers: [
                        { provide: HTTP_INTERCEPTORS, useClass: PrismeBearerInterceptor, multi: true },
                    ]
                }]
        }] });

class DefaultFailureLoginHandler extends AbstractFailureLoginHandler {
    postFailureLogin() {
        console.log('Dans default failure Login Handler');
        alert('Une erreur est survenue lors de l\'authentification');
    }
}
DefaultFailureLoginHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: DefaultFailureLoginHandler, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
DefaultFailureLoginHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: DefaultFailureLoginHandler });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: DefaultFailureLoginHandler, decorators: [{
            type: Injectable
        }] });

class DefaultSuccessLoginHandler extends AbstractSuccessLoginHandler {
    constructor(environment, initConfig) {
        // Appel du constrcuteur du parent
        super();
        this.environment = environment;
        this.initConfig = initConfig;
        // Test des paramètres obligatoires
        if (!this.initConfig.cleStockagePageFrom) {
            throwError('Paramètre manquant : cleStockagePageFrom. Est t-il bien présent dans le fichier environnement.ts ?');
        }
        if (!this.environment.pageApresConnexion) {
            throwError('Paramètre manquant : pageApresConnexion. Est t-il bien présent dans le fichier environnement.ts ?');
        }
    }
    postSuccessLogin() {
        // Méthode à surcharger permettant d'ajouter un comportement après l'authentification
        console.log('Dans DefaultSuccessLoginHandler');
    }
}
DefaultSuccessLoginHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: DefaultSuccessLoginHandler, deps: [{ token: PrismeAngularConfiguration }, { token: PrismeAngularInitConfig }], target: i0.ɵɵFactoryTarget.Injectable });
DefaultSuccessLoginHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: DefaultSuccessLoginHandler });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: DefaultSuccessLoginHandler, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: PrismeAngularConfiguration, decorators: [{
                    type: Inject,
                    args: [PrismeAngularConfiguration]
                }] }, { type: PrismeAngularInitConfig }]; } });

/**
 * Ce module permet de charger la configuration de prisme.Il va de paire avec le module
 * PrismeAngularInitConfiguration
 *
 * @export
 */
class PrismeAngularModule {
}
PrismeAngularModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PrismeAngularModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PrismeAngularModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.1.0", ngImport: i0, type: PrismeAngularModule, declarations: [CallbackComponent], imports: [CommonModule, i3.RouterModule], exports: [CallbackComponent] });
PrismeAngularModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PrismeAngularModule, providers: [
        // L'application appelante doit fournir un prismeAngularConfiguration
        { provide: PrismeAngularConfiguration, useExisting: 'PrismeAngularConfiguration' },
        // Si l'application appelante ne surcharge par le success andler, alors on utilise celui par défaut.
        { provide: PRISME_SUCCESS_LOGIN_HANDLER, useClass: DefaultSuccessLoginHandler },
        // Si l'application appelante ne surcharge par le failure handler, alors on utilise celui par défaut.
        { provide: PRISME_FAILURE_LOGIN_HANDLER, useClass: DefaultFailureLoginHandler },
    ], imports: [CommonModule,
        RouterModule.forRoot([], { relativeLinkResolution: 'legacy' })] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PrismeAngularModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule,
                        RouterModule.forRoot([], { relativeLinkResolution: 'legacy' })],
                    declarations: [CallbackComponent],
                    exports: [CallbackComponent],
                    providers: [
                        // L'application appelante doit fournir un prismeAngularConfiguration
                        { provide: PrismeAngularConfiguration, useExisting: 'PrismeAngularConfiguration' },
                        // Si l'application appelante ne surcharge par le success andler, alors on utilise celui par défaut.
                        { provide: PRISME_SUCCESS_LOGIN_HANDLER, useClass: DefaultSuccessLoginHandler },
                        // Si l'application appelante ne surcharge par le failure handler, alors on utilise celui par défaut.
                        { provide: PRISME_FAILURE_LOGIN_HANDLER, useClass: DefaultFailureLoginHandler },
                    ]
                }]
        }] });

/*
 * Public API Surface of prisme-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractFailureLoginHandler, AbstractSuccessLoginHandler, AuthImplicitGuard, CallbackComponent, InfosUtilisateur, LoginService, OauthService, PRISME_FAILURE_LOGIN_HANDLER, PRISME_SUCCESS_LOGIN_HANDLER, PrismeAngularConfiguration, PrismeAngularInitModule, PrismeAngularModule, RefreshService };
//# sourceMappingURL=acoss-prisme-angular-intranet.mjs.map
