/**
* Configuration du build de la librairie angular acoss-icones.
* Quelques petits éléments à comprendre/savoir :
*    - Le numéro de version n'est pas porté par la version dans le package.json mais par le nom de la branche
* 	 - Le numéro de version dans le package.json est automatiquement mis à jour par le build
*    - Les branches sans "numero" (feature / develop) portent un numero fictif
*	 - En début de build on définit un ensemble de variables qui permettent de simplifier la configuration des steps suivants
*    - Deux images docker sont utilisées : Une pour la construction du projet avec npm et une pour générer le rpm et pousser sous fedex
*	 - Les étapes executées dépendent des branches git sur laquelle le projet est buildé
*    - Il faut penser à ajouter l'utilisateur jenkins dans les membres de votre projet git
* 	 - Pour faire fonctionner le plugin hawai, il faut avoir un fichier hawai.properties, qui contient les même clés/valeurs
*  que la partie <configuration> que l'on trouve dans le plugin maven
*
* Les étapes principales du builds sont :
*	- Récupération du numéro de version depuis le nom de la branche et mise à jour dans le package.json (agent node-npm du stage Npm Tasks)
* 	- Compilation du projet (agent node-npm du stage Npm Tasks)
*   - git push des modifications de versions (attention : agent docker déclaré en début de pipeline)
*   - git tag en cas release sur la branche master uniquement
*   - Deploiement sous fedex
*/

pipeline {

  // Agent Jenkins utilisé par défaut
  agent { label 'docker'}

  // Définition de variables qui sont utilisé dans le build
  environment {
    HOME = '.'
  }
  triggers {
    // Lancement automatique du build sur la branche develop tous les jours à 06h00
    cron(env.BRANCH_NAME == 'develop' ? '''00 06 * * *''' : "")
  }
  stages {
    // La compilation maven se fait à partir d'une image docker node-npm. On regroupe toutes ces étapes dans un bloque stages (avec un "s")
		stage ('Npm Tasks') {
      agent {
      	// Configuration de l'image utilisée pour les étapes suivantes
        docker {
          image 'acoss/generique/node10-npm6-openjdk11-maven3.fr-sonar4-slim:latest'
        }
      }
      stages{
        // Dans notre workflow, la version n'est pas portée par le package.json mais par le nom de la branche
		    // Ce stage met donc à jour la version dans les package.json en fonction du nom de la branche
				// Ces modifications sont poussées sous GIT
        //Ce stage permet de mettre jour les variables en fonction de la branche sur laquelle est lancée le job
        stage('Set parametres'){
          steps{
            script {
              //Les variables mises à jour dans ce build sont :
              // VERSION = version du projet
              // NPM_OPTION = option npm pour permettre de publier plusieurs fois la meme version (pour les versions de développement uniquement)
              // MAVEN_REPOSITORY = permet de définir le repository nexus (maven) ou seront déposé les livrables
              if (env.BRANCH_NAME == 'develop' || env.BRANCH_NAME.startsWith('feature/') || env.BRANCH_NAME.startsWith('hotfix/') ) {
                // En Feature, develop ou hotfix on met un numero fictif (1.0.0) suivi d'un snapshot
                VERSION = "1.0.0-${GIT_BRANCH.replaceAll('/','-').replaceAll('origin-','').replaceAll('_','')}-SNAPSHOT"
                NPM_OPTION = "--allow-same-version"
                MAVEN_REPOSITORY="maven-snapshots"
                BRANCHE_HAWAI = "develop"
              } else if (env.BRANCH_NAME.startsWith('release/') ) {
                // En release on met des RC + nombre de commit sur la branche suivi d'un snapshot
                VERSION = "${GIT_BRANCH.replaceAll('/','-').replaceAll('origin-','').replaceAll('release-','').replaceAll('_','')}" + '-RC-' + "${env.BUILD_NUMBER}"
                NPM_OPTION = ""
                MAVEN_REPOSITORY="maven-releases"
                BRANCHE_HAWAI = "develop"
              } else if (env.BRANCH_NAME == 'master') {
                //Sur master,on enlève la partie RC-XXX-SNAPSHOT pour avoir le numéro de version.
                CURRENT_VERSION = sh(script: 'node -e "console.log(require(\'./package.json\').version);"', returnStdout: true)
                VERSION = "${CURRENT_VERSION.trim().split('-')[0]}"
                NPM_OPTION = ""
                BRANCHE_HAWAI = "trunk"
              } else {
                  echo 'ERREUR  : Nomenclature de branche inconnue'
              }
            }
          }
        }
        stage('Set version') {
					steps {
						script {
              echo "${VERSION}"
              // on met à jour la version dans le package.json et le package-lock.json
              withCredentials([string(credentialsId: 'NPM_PUBLISH_TOKEN', variable: 'NPM_CONFIG__AUTH')]) {
                withEnv(['npm_config_email="indus@acoss.fr"']) {
                	// no-git-tag-version permet de ne pas commiter la nouvelle version et ne pas créer de tag
                  // Les mises à jour dans Git seront effectuées dans les étapes suivantes si le build est correct
                  sh "npm --no-git-tag-version version ${VERSION} ${NPM_OPTION}"
                }
              }
              // Le stash est nécessaire pour l'étape de git push version (on sauvegarde les fichiers que l'on vient de modifier).
							stash includes: '*', name: 'wkspace'
						}
					}
				}
        // Compilation
        stage('npm install') {
					steps {
						withNPM(npmrcConfig:'npmrc') {
              sh 'npm install'
						}
					}
				}
        // Publication sous nexus
        stage('Publish nexus') {
          steps {
            withCredentials([string(credentialsId: 'NPM_PUBLISH_TOKEN', variable: 'NPM_CONFIG__AUTH')]) {
              withEnv(['npm_config_email="indus@acoss.fr"']) {
                sh 'npm publish'
              }
            }
          }
        }
      }
    }
    // Commit et push des fichiers package.json contenant les modifications de version
    // Attention ici on utilise l'agent docker (délaré en début de pipeline)
    stage ('Git push version') {
      environment {
        GIT_AUTH = credentials('GITLAB_ID')
      }
      steps {
        unstash 'wkspace' // permet de récupérer les changements de version sur les fichier package.json
		catchError(buildResult: 'SUCCESS', stageResult: 'UNSTABLE') { //Si la version est déjà a jour alors on ignore l'erreur
          sh "git ls-files . | grep package | xargs git add"
          sh "git commit -m \"mise à jour de version\""
          sh 'git config --local credential.helper "!f() { echo username=\\$GIT_AUTH_USR; echo password=\\$GIT_AUTH_PSW; }; f"'
          sh "git push origin HEAD:${GIT_BRANCH.replaceAll('origin/','')}"
        }
      }
    }
    // Création et publication d'un tag uniquement si on est sur la branche master
    // Attention ici on utilise l'agent docker (délaré en début de pipeline)
    stage ('Git tag version') {
      when {
        branch 'master'
      }
      environment {
        GIT_AUTH = credentials('GITLAB_ID')
      }
      steps {
        sh "git tag ${VERSION} -m \"release v${VERSION} \""
        sh 'git config --local credential.helper "!f() { echo username=\\$GIT_AUTH_USR; echo password=\\$GIT_AUTH_PSW; }; f"'
        sh "git push origin HEAD:${GIT_BRANCH.replaceAll('origin/','')} ${VERSION}"
      }
    }
  }
  post {
    failure {
        mail to: 'ac750-dsi-sded-bt-aea@acoss.fr',
            subject: "Jenkins build failure : ${currentBuild.fullDisplayName}",
            body: " Log du build en erreur :  ${env.BUILD_URL}"
    }
  }
}
