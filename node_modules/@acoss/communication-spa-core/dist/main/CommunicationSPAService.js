"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommunicationSPAServiceFactory = void 0;
const Child_1 = require("./Child");
const CommunicationSPAServiceExports_1 = require("./CommunicationSPAServiceExports");
const ComponentMessageHandler_1 = require("./ComponentMessageHandler");
const uuid_1 = require("./uuid");
/**
 * Ensemble des namespaces/topics utilisés en interne par le composant de communication
 */
class CommunicationConstants {
}
CommunicationConstants.NAMESPACE = 'communication';
CommunicationConstants.HANDSHAKE_READY_TOPIC = 'handshake_ready';
/**
 * Implémentation TypeScript du service
 */
class CommunicationSPAServiceImpl {
    /**
     * Défini :
     *  - Si le noeud est racine
     *  - S'il n'est pas racine lui affecte le noeuf parent
     *    (window.parent pour les iframe, window.opener pour les tabs ou fenêtres détachées)
     *
     * Mise en place de l'event listener central sur postMessage qui :
     *  - Active les handler Applicatifs
     *  - Se charge de rediriger les messages aux parents/enfants pour permettre la communication entre tous les composants IHM
     */
    constructor(appName) {
        this.myUUID = (0, uuid_1.uuidv4)();
        this.childs = {};
        this.handlers = {};
        this.appName = appName;
        // https://developer.mozilla.org/fr/docs/Web/API/Window/parent
        // Si une fenêtre n'a pas de parent, sa propriété parent
        // est une référence vers elle-même.
        if (window.parent !== window.self) {
            this.parent = window.parent;
        }
        if (window.opener) {
            this.parent = window.opener;
        }
        // Ajout de l'event listener central
        const theComService = this;
        window.addEventListener('message', (messageEvent) => {
            // Pour le traitement, on vérifie que la version du layer correspond
            // et qu'il n'est pas de type BROADCAST.
            // (Les messages BROADCAST ne sont pas traité en remontée mais les redescentes CHILD le seront)
            if (messageEvent.data
                && messageEvent.data.layerVersion === CommunicationSPAServiceImpl.layerVersion) {
                // Parsing du message DTO
                const message = messageEvent.data;
                if (messageEvent.data.scope !== CommunicationSPAServiceExports_1.MessageScope.BROADCAST) {
                    // Lancement des handlers projet
                    Object.keys(theComService.handlers).forEach((key) => {
                        theComService.messageHandlerManagment(theComService.handlers[key], messageEvent);
                    });
                }
                this.handleHandshakeCommunication(message, messageEvent);
                // Redirection des message
                this.handleInterNodeCommunication(this, message);
            }
        }, false);
        console.log('instance de la lib de comm créée pour l\'application ' + appName + ' (root ? ' + this.isRootCommunicator() + ')');
    }
    /**
     * Indique si le noeud est racine
     * @returns true si le noeud est central, faux sinon (noeud enfant ou encapsulé dans RCP)
     */
    isRootCommunicator() {
        return !window.opener && (window.top === window.self) && !window.portail_postMessage;
    }
    /**
     * Retourne l'UUID réel du composant courant
     * @returns UUID réel du composant
     */
    getUUID() {
        return this.myUUID;
    }
    /**
     * Méthode à appeler une fois les handlers enregistrés afin d'activer la communication
     * La méthode aura pour effet de débloquer l'envoi des messages d'init par le parent
     */
    applicationReadyActivateCommunication() {
        // Envoi du message d'initiation du handshake au parent is non root
        if (!this.isRootCommunicator()) {
            this.sendHandshakeReadyMessage();
        }
    }
    /**
     * Ajout d'un composant enfant de communication inter IHM
     * Permet d'ouvrir le canal de communication via le Handshake
     * @param componentWindow Composant HTML qui sera utilisé pour réaliser la communication
     * @param handshakeTimeoutMS Délai d'attente de résolution du handshake avant levée d'une erreur
     * @param timeoutCallback Fonction callback appelé en cas de levée du timeout
     * @returns UUID du composant enfant (vision parent != uuid vision enfant)
     */
    addChildComponent(componentWindow, handshakeTimeoutMS, timeoutCallback) {
        if (!componentWindow) {
            throw new Error('Can\'t create a Child without window component');
        }
        const newChild = new Child_1.Child(componentWindow, handshakeTimeoutMS, timeoutCallback);
        this.childs[newChild.childParentVisionUUID] = newChild;
        return newChild.childParentVisionUUID;
    }
    /**
     * Suppression d'un composant enfant
     * @param componentUUID UUID du composant enfant à supprimer
     */
    removeChildComponent(componentUUID) {
        delete this.childs[componentUUID];
    }
    /**
     * Recherche de l'UUID réel (!vision parent) ayant l'UUID enfant fourni (vision parent)
     *
     * @param componentUUID UUID local du composant
     * @returns UUID réel du composant s'il est connu (= handshake realisé et enfant de niveau 1)
     */
    getChildToRealUUID(componentUUID) {
        if (this.childs[componentUUID]) {
            return this.childs[componentUUID].childUUID;
        }
        return undefined;
    }
    /**
     * Recherche de l'UUID enfant (vision parent) ayant l'UUID réel (!vision parent) fourni
     *
     * @param realUUID UUID réel du composant dont on souhaite rechercher l'UUID enfant (du composant local)
     * @returns UUID enfant du composant s'il est connu (= handshake realisé et enfant de niveau 1)
     */
    getRealToChildUUID(realUUID) {
        let result;
        Object.keys(this.childs).forEach((key) => {
            if (this.childs[key].childUUID === realUUID) {
                result = this.childs[key].childParentVisionUUID;
            }
        });
        return result;
    }
    /**
     * Libération mémoire de la librairie
     * = suppression de la référence au parent et aux enfants
     */
    destroy() {
        this.childs = {};
        this.handlers = {};
        this.parent = null;
    }
    /**
     * SUPER
     */
    subscribe(namespaceRegEx, topicRegEx, handlerFunction) {
        const newHandlerUUID = (0, uuid_1.uuidv4)();
        this.handlers[newHandlerUUID] = new ComponentMessageHandler_1.ComponentMessageHandler(namespaceRegEx, topicRegEx, this.myUUID, handlerFunction);
        return newHandlerUUID;
    }
    /**
     * SUPER
     */
    unsubscribe(observerUUID) {
        delete this.handlers[observerUUID];
    }
    /**
     * SUPER
     */
    unsubscribeAll() {
        this.handlers = {};
    }
    /**
     * SUPER
     */
    sendChildInitMessage(namespace, topic, payload, componentUUID) {
        // All message will be sent after the handshake with the child.
        // If Handshake has been done, Promise resolved, it will also send them directly
        const child = this.childs[componentUUID];
        if (child) {
            const message = new CommunicationSPAServiceExports_1.MessageDTO(namespace, topic, this.appName, undefined, // reply_to_uuid
            undefined, // destinationUUID (on ne cible pas le destinataire car l'on n'a pas encore l'UUID à ce stade.
            // Le message étant direct il n'y a pas d'impact fonctionnel)
            this.myUUID, // sender uuid
            CommunicationSPAServiceExports_1.MessageScope.DIRECT, CommunicationSPAServiceImpl.layerVersion, payload);
            child.handshakeFinishedPromise.then(() => {
                this.sendMessageToUUID(componentUUID, message);
            });
        }
        else {
            throw new Error('No child component for UUID : ' + componentUUID);
        }
    }
    /**
     * SUPER
     */
    sendReplyMessage(namespace, topic, payload, originMessageObject) {
        if (this.isRootCommunicator()) {
            const message = new CommunicationSPAServiceExports_1.MessageDTO(namespace, topic, this.appName, originMessageObject.uuid, // reply_to_uuid
            originMessageObject.senderUUID, // destinationUUID
            this.myUUID, // sender uuid
            CommunicationSPAServiceExports_1.MessageScope.CHILDS, CommunicationSPAServiceImpl.layerVersion, payload);
            this.sendChildrenRawMessage(message);
        }
        else {
            const message = new CommunicationSPAServiceExports_1.MessageDTO(namespace, topic, this.appName, originMessageObject.uuid, // reply_to_uuid
            originMessageObject.senderUUID, // destinationUUID
            this.myUUID, // sender uuid
            CommunicationSPAServiceExports_1.MessageScope.BROADCAST, CommunicationSPAServiceImpl.layerVersion, payload);
            this.sendParentRawMessage(message);
        }
    }
    /**
     * SUPER
     */
    sendBroadcastMessage(namespace, topic, payload) {
        // Si noeud root
        if (this.isRootCommunicator()) {
            const message = new CommunicationSPAServiceExports_1.MessageDTO(namespace, topic, this.appName, undefined, // reply_to_uuid
            undefined, // destinationUUID
            this.myUUID, // sender uuid
            CommunicationSPAServiceExports_1.MessageScope.CHILDS, CommunicationSPAServiceImpl.layerVersion, payload);
            this.sendChildrenRawMessage(message);
        }
        else {
            const message = new CommunicationSPAServiceExports_1.MessageDTO(namespace, topic, this.appName, undefined, // reply_to_uuid
            undefined, // destinationUUID
            this.myUUID, // sender uuid
            CommunicationSPAServiceExports_1.MessageScope.BROADCAST, CommunicationSPAServiceImpl.layerVersion, payload);
            this.sendParentRawMessage(message);
        }
    }
    /**
     * SUPER
     */
    sendChildrenMessage(namespace, topic, payload) {
        const message = new CommunicationSPAServiceExports_1.MessageDTO(namespace, topic, this.appName, undefined, // reply_to_uuid
        undefined, // destinationUUID
        this.myUUID, // sender uuid
        CommunicationSPAServiceExports_1.MessageScope.CHILDS, CommunicationSPAServiceImpl.layerVersion, payload);
        Object.keys(this.childs).forEach((key) => {
            this.sendMessageToChild(this.childs[key], message);
        });
    }
    /**
     * SUPER
     */
    sendChildMessage(namespace, topic, payload, componentUUID) {
        // Vérification de l'existence du composant ciblé
        const targetChild = this.childs[componentUUID];
        if (!targetChild) {
            throw new Error('Direct message error, no child component for UUID : ' + componentUUID); // componentUUID = UUID vision parent
        }
        // Vérification que le Handshake est finalisé (sans quoi le message pourrait être transmis à tous)
        if (!targetChild.childUUID) {
            throw new Error('Direct message error, Handshake not done with child : ' + componentUUID); // componentUUID = UUID vision parent
        }
        // Préparation du message
        const message = new CommunicationSPAServiceExports_1.MessageDTO(namespace, topic, this.appName, undefined, // reply_to_uuid
        targetChild.childUUID, // destinationUUID (= UUID réel, vision enfant)
        this.myUUID, // sender uuid
        CommunicationSPAServiceExports_1.MessageScope.DIRECT, CommunicationSPAServiceImpl.layerVersion, payload);
        // Envoi du message
        this.sendMessageToUUID(componentUUID, message);
    }
    /**
     * SUPER
     */
    sendParentMessage(namespace, topic, payload) {
        const message = new CommunicationSPAServiceExports_1.MessageDTO(namespace, topic, this.appName, undefined, // reply_to_uuid
        undefined, // destinationUUID
        this.myUUID, // sender uuid
        CommunicationSPAServiceExports_1.MessageScope.DIRECT, CommunicationSPAServiceImpl.layerVersion, payload);
        // Si racine dans un portail
        return this.sendParentRawMessage(message);
    }
    //
    // PRIVATE
    //
    /**
     * Envoie un message au parent (s'il existe).
     * @param message Le message.
     * @return `true` si le parent existe
     */
    sendParentRawMessage(message) {
        if (this.parent) {
            // on a un parent, on lui envoie le message
            this.sendMessageToWindow(this.parent, message);
        }
        else if (window.portail_postMessage) {
            // intégré au portail rcp, c'est lui notre parent
            window.portail_postMessage('fr/acoss/portail/webapps/interop', JSON.stringify(message));
        }
        else {
            // ce n'est à priori pas une erreur de ne pas avoir de parent
            // throw new Error('No parent, can\'t send message');
            return false;
        }
        return true;
    }
    /**
     * Envoie un message à tous nos enfants (s'il y en a).
     * @param message Le message.
     */
    sendChildrenRawMessage(message) {
        Object.keys(this.childs).forEach((key) => {
            this.sendMessageToChild(this.childs[key], message);
        });
    }
    /**
     * Envoi d'un message directement à une fenêtre.
     * @param targetWindow objet IHM à qui envoyer le message
     * @param message message transmis
     */
    sendMessageToWindow(targetWindow, message) {
        if (targetWindow) {
            targetWindow.postMessage(message, '*');
        }
        else {
            throw new Error('No targetWindow');
        }
    }
    /**
     * Envoi d'un message à une IHM enfant
     * @param targetChild enfant à qui envoyer le message
     * @param message message transmis
     */
    sendMessageToChild(targetChild, message) {
        if (targetChild.window) {
            this.sendMessageToWindow(targetChild.window, message);
        }
        else {
            throw new Error('No window for child component');
        }
    }
    /**
     * Envoi d'un message à une IHM enfantvia son UUID
     * @param componentUUID UUID de l'IHM enfant à qui l'on souhaite envoyer un message
     * @param message message transmis
     */
    sendMessageToUUID(componentUUID, message) {
        const child = this.childs[componentUUID];
        if (child) {
            this.sendMessageToChild(child, message);
        }
        else {
            throw new Error('No child component for UUID : ' + componentUUID);
        }
    }
    /**
     * Envoi d'un message de handshake READY au parent
     *
     * (Dernière méthode appelée par le constucteur)
     */
    sendHandshakeReadyMessage() {
        const message = new CommunicationSPAServiceExports_1.MessageDTO(CommunicationConstants.NAMESPACE, CommunicationConstants.HANDSHAKE_READY_TOPIC, this.appName, undefined, // reply_to_uuid
        undefined, // destinationUUID
        this.myUUID, // sender uuid
        CommunicationSPAServiceExports_1.MessageScope.BROADCAST, CommunicationSPAServiceImpl.layerVersion, undefined);
        this.sendParentMessage(CommunicationConstants.NAMESPACE, CommunicationConstants.HANDSHAKE_READY_TOPIC, message);
    }
    /**
     * Méthode de solicitation des handlers
     * @param handler Handler qui sera vérifié et lancé si les namespace et topic matchent le message
     * @param messageEvent Evenement qui sera traité
     */
    messageHandlerManagment(handler, messageEvent) {
        const message = messageEvent.data;
        // Si le message n'est pas ciblé (ou s'il m'est destiné)
        // ET s'il ne s'agit pas d'un message provenant de moi
        // ET s'il match le namespace
        // ET s'il match topic du handler
        if ((!message.destinationUUID || message.destinationUUID === handler.componentUUID)
            && message.senderUUID !== this.myUUID
            && message.namespace.match(handler.namespaceRegEx)
            && message.topic.match(handler.topicRegEx)) {
            // On renseigne le children UUID (si trouvé, sinon défini à undefined)
            message.childComponentUUID = this.getRealToChildUUID(message.senderUUID);
            if (message.value) {
                handler.handler(JSON.parse(message.value), message);
            }
            else {
                handler.handler(message.value, message);
            }
        }
    }
    /**
     * Méthode permettant de gérer la redirection des messages et donc la communication entre IHM
     *
     * (Elle est utilisée par le handler racine qui est enregistré à l'initialisation du service)
     *
     * @param comService service de communication qui est utilisé pour retransmettre les messages,
     *                   transmis car il est enregistré sous forme de closure dans le handler)
     * @param message message reçu dont on souhaite assurer la redirection (s'il y a lieu, la methode recoit tous les messages)
     */
    handleInterNodeCommunication(comService, message) {
        // Redescente de tous les messages de scope CHILD
        if (+message.scope === CommunicationSPAServiceExports_1.MessageScope.CHILDS) {
            comService.sendChildrenRawMessage(message);
        }
        else if (+message.scope === CommunicationSPAServiceExports_1.MessageScope.BROADCAST) {
            if (!this.isRootCommunicator()) {
                // on est pas le noeud racine, remontée
                // du message de BROADCAST tel quel vers le parent
                comService.sendParentRawMessage(message);
            }
            else {
                // on est le noeud racine, redescente
                // du message à tous les enfants
                message.scope = CommunicationSPAServiceExports_1.MessageScope.CHILDS;
                // Envoi du message à soi-même pour le traiter et le retransmettre aux autres
                comService.sendMessageToWindow(window, message);
            }
        }
        else {
            // Les messages DIRECT ne sont pas retransmis
        }
    }
    /**
     * Méthode permettant de gérer la redirection des messages et donc la communication entre IHM
     *
     * (Elle est utilisée par le handler racine qui est enregistré à l'initialisation du service)
     *
     * @param comService service de communication qui est utilisé pour retransmettre les messages,
     *                   transmis car il est enregistré sous forme de closure dans le handler)
     * @param message message reçu dont on souhaite assurer la redirection (s'il y a lieu, la methode recoit tous les messages)
     */
    handleHandshakeCommunication(message, messageEvent) {
        if (message.namespace === CommunicationConstants.NAMESPACE
            && message.topic === CommunicationConstants.HANDSHAKE_READY_TOPIC) {
            let found = false;
            Object.keys(this.childs).forEach((key) => {
                const aChild = this.childs[key];
                if (aChild.window === messageEvent.source) {
                    found = true;
                    aChild.childUUID = message.senderUUID;
                    aChild.handshakeFinishedResolver();
                }
            });
            if (!found) {
                throw new Error('handleHandshakeCommunication : No child component matching');
            }
        }
    }
}
CommunicationSPAServiceImpl.layerVersion = '1.0';
/**
 * Implémentation TypeScript du service
 */
class CommunicationSPAServiceFactory {
    static getCommunicationSPAService(appName) {
        return new CommunicationSPAServiceImpl(appName);
    }
}
exports.CommunicationSPAServiceFactory = CommunicationSPAServiceFactory;
